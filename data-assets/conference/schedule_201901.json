{"version":"1.2352","conference":{"title":"Qt World Summit 2019","start":"2019-11-04","end":"2019-11-06","timeslot_duration":"","days":{"2019-11-04":{"index":0,"date":"2019-11-04","rooms":{"TBA 1":[{"id":4524,"start":"09:00","duration":"08:00","room":"TBA 1","slug":"introduction-to-cmake","title":"Introduction to CMake","subtitle":"","tracks":[{"name":"Introductory courses","color":"#39ff14"},{"name":"Training","color":"#39ff14"}],"track":"","type":"","language":"","abstract":"","description":"“The best thing a build system can do is not get in the way”.\r\n\r\nCMake is the de facto standard build system for C and C++ outside of frameworks that require their own. It has earned this place by supporting the situations and special cases that arise in real projects.\r\n\r\nSupport for CMake within Qt is being significantly improved and there are longer term plans to switch to CMake for building Qt itself. It’s currently a good alternative if you hit limitations in qmake.\r\n\r\nThis course will teach the basics of creating and building projects with CMake. In recent years, CMake has introduced some cleaner and more precise constructs. The course will focus on the new constructs where possible.\r\n\r\nWhy learn CMake?\r\nCMake has broad functionality that covers many real world problems. Learning CMake enables you to solve advanced build requirements. This includes cross-platform builds, feature detection based on platform or available libraries, built- time configurable feature switches and custom build steps. CMake is increasingly widely adopted across the industry.\r\n\r\nTarget Audience: C and C++ Developers who are interested in how to build their code\r\n\r\nPrerequisite: Experience with build systems\r\n\r\nTrainer: Kevin Funk\r\nKevin has actively developed with Qt/C++ since 2006 and has a special interest in tooling and profiling. He's an active contributor to KDAB's GammaRay analyzer (a high-level Qt application debugger) and has a strong emphasis on state machine tooling. He is co-maintainer of the KDevelop IDE, a powerful C/C++ development environment backed by Clang, and is pushing for cross-platform success inside KDE. Kevin holds a Masters Degree in Computer Science","persons":[{"id":4526,"full_public_name":"KDAB","first_name":"KDAB","last_name":""}],"links":[]}],"TBA 2":[{"id":4525,"start":"09:00","duration":"08:00","room":"TBA 2","slug":"introduction-to-qml","title":"Introduction to QML","subtitle":"","tracks":[{"name":"Introductory courses","color":"#39ff14"},{"name":"Training","color":"#39ff14"}],"track":"","type":"","language":"","abstract":"","description":"This training is an introduction to Qt Quick. On the one hand it will teach you how to compose fluid user interfaces with slick animations using the QML language. On the other hand it will teach you how you hook the QML side up to your business logic in C++.\r\n\r\nCourse contents:\r\n\r\nConnecting a QML UX with C++ business logic\r\nComplex list views including data provided from C++ models\r\nCustom objects implemented using Qt Quick scene graph\r\nProfiling and best practices for optimal performance\r\nWhy learn Qt/QML?\r\nWhy learn Qt QML?\r\nDesigned to take people new to Qt or QML, from the basics to a deep functional understanding of best practices, this Qt/QML training will equip you with the skills and know-how to boost your productivity at work.\r\n\r\nTarget Audience: Developers and managers interested in learning the autonomy of a QML application\r\n\r\nPrerequisite: Knowing the basics of Qt at C++ level is an advantage but not a requirement\r\n\r\nTrainer: Jan Marker\r\nSoftware engineer at KDAB, Jan has been using Qt since 2009 when he started contributing to the KDE project. Since joining KDAB he has worked on multiple large Qt and QML projects, while more recently also developing Wayland compositors. Besides in-depth knowledge of Qt and C++, Jan also has a deep interest in other technologies like NodeJS. He holds a BSc in Computer Science","persons":[{"id":4526,"full_public_name":"KDAB","first_name":"KDAB","last_name":""}],"links":[]}],"TBA 3":[{"id":4528,"start":"09:00","duration":"08:00","room":"TBA 3","slug":"introduction-to-qt3d-studio","title":"Introduction to Qt3D Studio","subtitle":"","tracks":[{"name":"Introductory courses","color":"#39ff14"},{"name":"Training","color":"#39ff14"}],"track":"","type":"","language":"","abstract":"","description":"This training introduces designers and developers to 3D content workflows and concepts, giving them a solid grounding in creating content using Qt 3D Studio, achieving the visual results they require, and integrating their work with other Qt content such as Qt Quick.\r\n\r\nExisting 2D and 3D designers, user-experience designers, as well as developers working on visuals, will all benefit from learning the features and workflow offered by Qt 3D Studio. The training includes a large amount of hands-on time with the software, giving students confidence to begin creating their own content immediately, taking full advantage of the core features available.\r\n\r\nWhy learn Qt 3D Studio?\r\nQt 3D studio gives a tool-led workflow for integrating 3D content into Qt and QtQuick. It provides a simple environment for structuring 3D content, defining animations and behaviors, specifying materials and visual effects, and exporting complete presentations to an optimized runtime component.\r\n\r\nWhile a wide range of workflows are possible when integrating 3D content, this training allows you and your team to focus on the best-practice approaches when working with Qt 3D Studio, to give a robust and well-defined path from 3D content into your final product.\r\n\r\nTarget audience: Principally designers, or developers who need to get an overview of QML integration\r\n\r\nPrerequisite: No coding experience required, some familiarity with 3D concepts would be useful\r\n\r\nTrainer: Nuno Pinheiro\r\nSenior UX/UI designer at KDAB, Nuno did the first QML training for designers and actively uses the QML language for fast UX/UI prototyping and UI solutions deployment. His works include general illustrations, UI design, corporate design, interactive mock-ups, animation examples and much more. Known for his contribution to the award winning Oxygen Project where he is the current coordinator, his computer art is used on KDE computer platforms worldwide. Nuno has an MSc in Civil Engineering.","persons":[{"id":4526,"full_public_name":"KDAB","first_name":"KDAB","last_name":""}],"links":[]}],"TBA 4":[{"id":4529,"start":"09:00","duration":"08:00","room":"TBA 4","slug":"multithreading-in-qt","title":"Multithreading in Qt","subtitle":"","tracks":[{"name":"Introductory courses","color":"#39ff14"},{"name":"Training","color":"#39ff14"}],"track":"","type":"","language":"","abstract":"","description":"Multithreaded programming is essential for developers to create fast and responsive applications on computers, phones and embedded devices, all with an increasing number of cores. Qt offers several mechanisms for multithreading; however, it can be difficult to know which to use and how to steer clear of common pitfalls. This course offers guidance for writing safe and efficient multithreaded code with Qt.\r\n\r\nWhy learn about Multithreading with Qt?\r\nMultithreaded development is a complex subject where it is easy to write code that contains severe bugs yet looks correct. This training will provide a solid foundation for writing safe and effective multithreaded code in Qt applications.\r\n\r\nTarget Audience: Qt Developers interested in multithreaded programming\r\n\r\nPrerequisite: Knowledge and experience programming with Qt and C++. A basic understanding of multithreaded programming is an advantage but not required.\r\n\r\nTrainer: András Mantia\r\nSenior software engineer at KDAB. András has actively developed with Qt since 2002 and is a core developer of KDE’s web development environment Quanta Plus and contributor to other parts of KDE. He talks at free software events about Qt-based products and has held training courses for companies such as Accenture, TietoEnator and Nokia","persons":[{"id":4526,"full_public_name":"KDAB","first_name":"KDAB","last_name":""}],"links":[]}],"TBA 5":[{"id":4530,"start":"09:00","duration":"08:00","room":"TBA 5","slug":"qt-gui-testing-with-squish","title":"Qt GUI Testing with Squish","subtitle":"","tracks":[{"name":"Introductory courses","color":"#39ff14"},{"name":"Training","color":"#39ff14"}],"track":"","type":"","language":"","abstract":"","description":"In order to achieve high-quality applications during the testing process, all the functionality of the software shall be covered, including fully exercising GUI itself. For regression testing automating this process gives benefits, saving execution time and increasing accuracy. On the other hand, GUI Automation might be a challenge, as GUI may change significantly during a product life cycle. In this course, we learn how to design and implement cross-platform automated tests using Squish GUI Tester for Qt, QML & QtQuick applications that continue to work as your product evolves.\r\n\r\nYou will learn:\r\n\r\nIntroduction to GUI Testing\r\nSquish Overview (installation, configuration)\r\nTest Script Creation and Execution\r\n- Recording and Replaying Test Scripts\r\n- Verification Points (Properties, Screenshot, Visual)\r\n- Test Results and Logging\r\n- Squish API\r\n- Image-Based Lookup\r\n- Set-Up and Tear-Down Functions\r\n- Development of Test Cases at Business Level\r\nObject Recognition\r\nSynchronization\r\nDebugging Test Scripts\r\nAccessing Application Internals (Inspecting, Object Properties and Methods)\r\nSquish Command-Line Tools\r\nHooking into Running Applications\r\nSquish Integration with CI\r\n\r\nPrerequisites: The course is for developers and testers already familiar with the basic concepts of Qt.\r\n\r\nTrainer: Jakub Topolski\r\nJakub has worked in Quality Assurance since 2012. Over the years he has gained experience in manual, automatic and performance testing. A Python enthusiast, Jakub joined froglogic in 2016 to support Squish users, conduct trainings and consult. He graduated from the Gdansk University of Technology with a BSc in computer science.\r\n\r\nThis training is run by froglogic\r\n\r\n&nbsp;","persons":[{"id":4531,"full_public_name":"froglogic","first_name":"froglogic","last_name":""}],"links":[]}],"TBA 6":[{"id":4533,"start":"09:00","duration":"08:00","room":"TBA 6","slug":"modern-c-whats-new-in-c17","title":"Modern C++ - What's New in C++17?","subtitle":"","tracks":[{"name":"Advanced Courses","color":"#39ff14"},{"name":"Training","color":"#39ff14"}],"track":"","type":"","language":"","abstract":"","description":"At the end of 2017 the new C++17 standard was released, adding a sizeable amount of useful new features. All major compilers already support most (if not all) of these features.\r\n\r\nIn this training, the most useful of the new features introduced in C++17 and its predecessor will be presented. In cases for which these features depend on features introduced in C++11 or C++14, these will be refreshed as well.\r\n\r\nNew library features being presented include the new types std::any, std::optional and std::variant, the new parallel algorithms, filesystem access, std::string_view and new operations on the container classes. The new language features range from ways to improve template code with fold expressions, constexpr if, and class template deduction over improvements of lambdas to structured bindings and initalizers in if and switch statements.\r\n\r\nWhy learn what's new in C++17?\r\nC++ is the language that powers most applications written with Qt. To make the most out of the language, developers need to know its capabilities and pitfalls, and keep up with the incremental changes made in new releases. In this way they will learn to write easier, faster, cleaner and safer code.\r\n\r\nTarget Audience: C++ developers who want to know more about the new features introduced in C++17.\r\n\r\nPrerequisite: Knowing the basics of C++11 is a requirement, though more advanced topics will be explained as needed.\r\n\r\nTrainer: Marc Mutz\r\nMarc is a senior software engineer with KDAB and author of the “Effective Qt” series of articles. He originated KDAB’s “In-depth Multithreading With Qt”, C++11 and C++17 courses, and runs “-Wmarc”, a blog about Qt, C++ and Boost. The second-most prolific contributor to QtBase and former maintainer of the QtWidgets module, he has actively used the framework for more than a decade, first as a KDE contributor, and then on the job. His most recent contribution to Qt is QStringView, a revolutionary abstraction of string data from containers. Marc is a sought-after speaker at conferences on Qt and C++ topics and holds an MSc in Theoretical Physics","persons":[{"id":4526,"full_public_name":"KDAB","first_name":"KDAB","last_name":""}],"links":[]}],"TBA 7":[{"id":4534,"start":"09:00","duration":"08:00","room":"TBA 7","slug":"modern-opengl-advanced-pipeline-and-performance","title":"Modern OpenGL: Advanced Pipeline and Performance","subtitle":"","tracks":[{"name":"Advanced Courses","color":"#39ff14"},{"name":"Training","color":"#39ff14"}],"track":"","type":"","language":"","abstract":"","description":"This training explores strategies to increase the performance of new and existing OpenGL code, with multi-pass rendering and use of uniform buffers, shader storage buffers and indirect drawing to reduce driver overhead.\r\n\r\nWhy learn about advanced pipeline and performance?\r\nGetting the best from available hardware resources, especially on constrained systems, means deeply understanding the costs of different graphics operations, and how to optimise the rendering architecture to meet visual requirements. This course teaches how to increase performance effectively.\r\n\r\nTarget audience: Developers wanting to create or improve existing rendering code, using every technique at their disposal to understand and maximise performance, and extract the full potential from their hardware.\r\n\r\nPre-requisites: Developers already working with OpenGL, comfortable with the basics of specifying geometry, writing basic shaders and working with image data.\r\n\r\nTrainer: Giuseppe D'Angelo\r\nGiuseppe is a software engineer at KDAB and an Approver in the Qt Project. He is a long time contributor to Qt, having used Qt and C++ since 2000. His contributions in Qt range from containers and regular expressions to GUI, Widgets and OpenGL. A free software passionate and UNIX specialist, before joining KDAB, Giuseppe organized conferences on opensource around Italy. He holds a BSc in Computer Science","persons":[{"id":4526,"full_public_name":"KDAB","first_name":"KDAB","last_name":""}],"links":[]}],"TBA 8":[{"id":4535,"start":"09:00","duration":"08:00","room":"TBA 8","slug":"profiling-debugging-for-linux","title":"Profiling & Debugging for Linux","subtitle":"","tracks":[{"name":"Advanced Courses","color":"#39ff14"},{"name":"Training","color":"#39ff14"}],"track":"","type":"","language":"","abstract":"","description":"This training gives an introduction to various tools, which help developers and testers in finding bugs and performance issues. This variant of the training focuses on Linux. The tools presented cover a wide range of problems, from general purpose debugging and CPU profiling to Qt specific high-level analyzers. Often, it is relatively simple to run a tool, but interpreting the results, or even just using some of the more advanced tools, requires deep technical knowledge.\r\n\r\nThe following tools will be covered:\r\n\r\nDebugging\r\n\r\nGeneral purpose debugger: GDB\r\nRecord and replay, reverse debugging: RR\r\nMemory error detectors: AddressSanitizer\r\nThread error detectors: ThreadSanitizer\r\nVarious Qt built-in features\r\nGammaRay to investigate internals of Qt Applications\r\nStatic Code Analysis\r\n\r\nCompilers\r\nClazy\r\nProfiling\r\n\r\nCPU: Linux perf and hotspot\r\nHeap memory: heaptrack\r\nTarget audience: Developers who want to find and fix problems\r\n\r\nPrerequisite: Knowing the basics of C++ and Qt\r\n\r\nTrainer: Milian Wolff\r\nSenior software engineer at KDAB, Milian leads the R&D in tooling and profiling in which he has a special interest. Milian created Massif-Visualizer and heaptrack, both of which are now used regularly to improve the performance of C++ and Qt applications. When not applying his knowledge to improving code base performance for KDAB’s customers, Milian maintains QtWebChannel for the Qt Project and is co-maintainer of the KDevelop IDE. In 2015, Milian won KDE’s Akademy Award for his work on Clang integration. He has a Masters Degree in Physics","persons":[{"id":4526,"full_public_name":"KDAB","first_name":"KDAB","last_name":""}],"links":[]}]}},"2019-11-05":{"index":1,"date":"2019-11-05","rooms":{"B05":[{"id":4367,"start":"15:00","duration":"00:30","room":"B05","slug":"improve-productivity-efficiency-qt-mobile-desktop-embedded","title":"How to Improve Productivity & Efficiency with Qt on Mobile, Desktop & Embedded","subtitle":"","tracks":[{"name":"Application Development 1","color":"#EC7063  "}],"track":"","type":"","language":"","abstract":"","description":"All product teams face the same issues: software applications should be developed as fast as possible. Although complexity of applications rise, development speed is expected to accelerate as well. And all this while keeping a high quality standard for code, performance, UI and UX.\r\n\r\nIn this talk, you will find a solution to these challenges: you will learn how to BETTER USE the time developers spend on writing software. You will learn how to increase efficiency of software teams by using Qt-specific tools and frameworks, and by applying general productivity tips to accelerate your software development process with Qt. We will share our learnings from more than 200 completed software projects based on Qt for Mobile, Desktop and Embedded from the past 10 years working on the leading edge of Qt.\r\n\r\nSpecifically, you will learn:\r\n\r\n* How to optimize each step of the development lifecycle with hands-on tips for development, testing, distribution and maintenance\r\n\r\n* How to use live code reload and hot code reload to develop faster\r\n\r\n* Which components can help to accelerate your development process and how to find them\r\n\r\n* CI/CD tips for Qt applications\r\n\r\n* Automated testing tools and tips\r\n\r\n* How to effectively distribute product updates\r\n\r\n* How to measure and fix Qt application crashes in live environments\r\n\r\n* How to analyze Qt application usage to improve the product\r\n\r\n* General productivity tips for focused work and improved output\r\n\r\nThis talk is for both managers and software developers. The tips cover all platforms supported by Qt: Mobile, Desktop, Embedded and Web. Join and learn how to get more done in shorter time!","persons":[{"id":4295,"full_public_name":"Christian Feldbacher","first_name":"Christian","last_name":"Feldbacher"}],"links":[]},{"id":4664,"start":"17:00","duration":"00:30","room":"B05","slug":"build-qml-app-webos-qt-creator-webos-plugin","title":"How to Build QML Apps for webOS and Qt Creator webOS Plugin","subtitle":"","tracks":[{"name":"Application Development 1","color":"#EC7063  "}],"track":"","type":"","language":"","abstract":"","description":"The webOS platform supports applications developed with QML. These apps are executed within application containers which wrap the Qt QML engine. QML applications can be developed using webOS QML plugins and built using OpenEmbedded of Yocto Project. This talk will present How to build QML app for webOS target, and introduce Qt Creator webOS plugin.","persons":[{"id":4665,"full_public_name":"Yunkwan Kim","first_name":"Yunkwan","last_name":"Kim"}],"links":[]},{"id":4544,"start":"16:00","duration":"00:30","room":"B05","slug":"qt-widgets","title":"Integrating Custom Widgets With Qt Designer","subtitle":"","tracks":[{"name":"Application Development 1","color":"#EC7063  "}],"track":"","type":"","language":"","abstract":"","description":"This talk sheds some light on integration custom widgets with Qt Designer. Will be briefly described how to create a custom widget and in which cases it might be a good idea to integrate it as a designer component. After that, everything will be explained in more details: projects hierarchy, project type, interfaces, etc. As a result will be created a fully-functional widget that integrated with Qt Designer","persons":[{"id":4541,"full_public_name":"Vitaly Fanaskov","first_name":"Vitaly","last_name":"Fanaskov"}],"links":[]},{"id":4319,"start":"14:00","duration":"01:00","room":"B05","slug":"code-deploy-everywhere-can-simple","title":"Code Once, Deploy Everywhere. Can it be that simple?","subtitle":"","tracks":[{"name":"Application Development 1","color":"#EC7063  "}],"track":"","type":"","language":"","abstract":"","description":"Multi-platform products and services are becoming ubiquitous. Front-end applications are increasingly accessed from a variety of devices, from smartphones, to embedded touch panels, to web browsers. While \"Code Once, Deploy Everywhere\" has long been a motto for Qt, it has never been truer than today with the addition of two new major platforms, micro-controllers and the Web, thus enabling a variety of new use cases. Using a single concrete example, we will see how a Qt application can be built to target desktop, mobile, microprocessor and microcontroller based embedded systems, and web browsers, reusing most of the code. We will first go through the different elements to keep in mind through development to accommodate these very different platforms. Then, as it is not possible in most projects to write only cross-platform code, we will see what exactly might or must be platform-specific, and how Qt can help in this case. Finally, we will analyze the development breakdown to see what the true value of Qt is in this type of project.","persons":[{"id":4260,"full_public_name":"Becky Worledge","first_name":"Becky","last_name":"Worledge"}],"links":[]},{"id":4333,"start":"16:30","duration":"00:30","room":"B05","slug":"qml-architechture-design","title":"QML Architechture & Design","subtitle":"","tracks":[{"name":"Application Development 1","color":"#EC7063  "}],"track":"","type":"","language":"","abstract":"","description":"When writing QML applications, one of the most important parts is how to set up your software architecture. You are faced with a long list of design choices: What should go where? How do things communicate with each other? If you go wrong with these, you will hurt all development in your project. And even worse, those choices are the hardest to change later in the project. The aim of this talk is to give you an understanding of the choices you will be faced when deciding where to place the split between C++ and QML. When you understand the choices and the consequences of the decisions, you will be able to build better applications. I will also show you how the GUI layers can or should access the lower parts of the application. I will talk about the possible choices and why to choose one thing over another. For example, what is the consequence of instantiating an object in C++ and exposing this to QML versus exposing the type and instantiating in QML? I have written a lot of QML based applications, and finding this split between C++ and QML is always at the heart of the architecture. The decisions made here are vital for the maintainability of a project. And it is my hope that I can help you make better decisions after listening to this talk.","persons":[{"id":4258,"full_public_name":"Bo Thorsen","first_name":"Bo","last_name":"Thorsen"}],"links":[]}],"C01":[{"id":4396,"start":"09:30","duration":"00:15","room":"C01","slug":"opening","title":"Welcome to QtWS19","subtitle":"","tracks":[{"name":"Keynote","color":"#030056"}],"track":"","type":"","language":"","abstract":"","description":"","persons":[],"links":[]},{"id":4406,"start":"09:45","duration":"00:15","room":"C01","slug":"rimac-keynote","title":"Customer Keynote: Rimac Automobili","subtitle":"","tracks":[{"name":"Keynote","color":"#030056"}],"track":"","type":"","language":"","abstract":"","description":"","persons":[{"id":4438,"full_public_name":"Mate Rimac","first_name":"Mate","last_name":"Rimac"}],"links":[]},{"id":4407,"start":"10:00","duration":"00:15","room":"C01","slug":"keynote-2-tba","title":"Customer Keynote: LG Electronics - Future of Connected Cars and webOS Auto","subtitle":"","tracks":[{"name":"Keynote","color":"#030056"}],"track":"","type":"","language":"","abstract":"","description":"The keynote talks about how the automotive industry is changing recently and what value an operating system can provide in this transition. In addition, it examines the trends of the environment inside the automobile and explains how webOS is evolving as a SW platform to prepare for the future passenger experience.","persons":[{"id":4545,"full_public_name":"Heewon (Helen) Choi","first_name":"Heewon (Helen)","last_name":"Choi"}],"links":[]},{"id":4408,"start":"10:15","duration":"00:30","room":"C01","slug":"keynote-3-tba","title":"Keynote: Thomas Nattestad - How Chrome is Empowering Desktop Web Apps","subtitle":"","tracks":[{"name":"Keynote","color":"#030056"}],"track":"","type":"","language":"","abstract":"","description":"In this talk, learn about the myriad of ways that Chrome is dramatically expanding the power of applications on the web.\r\n\r\nQt recently added web support thanks to WebAssembly and this talk will give you an overview of why being on the web is powerful and what features you get access to.\r\n\r\nLearn how WebAssembly lets you run native code on the web, how PWAs let your web app feel like a true native app, and how advanced APIs like file system access close the capability gap between web and native applications. This talk will only touch briefly on Qt specifically but will be useful to any developer thinking about bringing their application to the web.","persons":[{"id":4312,"full_public_name":"Thomas Nattestad","first_name":"Thomas","last_name":"Nattestad"}],"links":[]},{"id":4409,"start":"10:45","duration":"00:45","room":"C01","slug":"keynote-4-tba","title":"Keynote: Nathalie Nahai - The Psychology Behind Great User Experience","subtitle":"","tracks":[{"name":"Keynote","color":"#030056"}],"track":"","type":"","language":"","abstract":"","description":"Whatever the interface you’re designing for, if you want to successfully engage users and drive them towards action, you have to understand the psychological motivations, biases and principles that shape their behaviour.\r\nFrom cognitive load to dopamine loops, we’ll explore some of the principles you can use to optimise your platform or product to create more resonant user experiences.","persons":[{"id":4442,"full_public_name":"Nathalie Nahai","first_name":"Nathalie","last_name":"Nahai"}],"links":[]},{"id":4411,"start":"12:00","duration":"01:00","room":"C01","slug":"qt-keynote-lars-knoll","title":"Qt Keynote: Lars Knoll","subtitle":"","tracks":[{"name":"Keynote","color":"#030056"}],"track":"","type":"","language":"","abstract":"","description":"","persons":[{"id":4433,"full_public_name":"Lars Knoll","first_name":"Lars","last_name":"Knoll"}],"links":[]},{"id":4318,"start":"14:00","duration":"01:00","room":"C01","slug":"state-future-directions-qt-graphics-stack","title":"The State and Future Directions of the Qt Graphics Stack","subtitle":"","tracks":[{"name":"Graphics & 3D","color":"#F8C471"}],"track":"","type":"","language":"","abstract":"","description":"The way Qt handles accelerated 2D and 3D graphics is facing its biggest changes since Qt 5.0. Relying solely on OpenGL is not going to be sufficient in the future due to a changing graphics API landscape on desktop, mobile, and embedded platforms. Qt Quick, Qt 3D Studio, and many bits and pieces in various Qt modules are expected to migrate away from the direct usage of OpenGL and GLSL shaders, in order to enable functioning on top of Vulkan, Metal, or Direct 3D, in addition to OpenGL. The enablers for this are expected to be introduced gradually in Qt 5.14, 5.15, and 6.0. In this talk, we are going to walk through the concepts and practicalities around this work, while looking at some live demonstrations of the new graphics abstraction APIs, the shader conditioning tools, the currently work-in-progress port of Qt Quick onto the new architecture, and discussing what all this means to application developers.","persons":[{"id":4256,"full_public_name":"Laszlo Agocs","first_name":"Laszlo","last_name":"Agocs"}],"links":[]},{"id":4330,"start":"15:00","duration":"00:30","room":"C01","slug":"qt-lottie-will-change-life","title":"Qt Lottie Will Change Your Life","subtitle":"","tracks":[{"name":"Graphics & 3D","color":"#F8C471"}],"track":"","type":"","language":"","abstract":"","description":"Lottie is a system to embed small graphics animations directly into applications. In the past, it was often necessary for engineers to recreate these animations in code, and embed them into the applications that way. Since the rise of the Lottie library this is no longer necessary: UX designers can now embed their designs into applications directly. The technology turns up often on mobile platforms, and makes complex micro-animations easy. Really easy. QtLottie is a new addition to the Qt framework, and provides a Qt-specific cross-platform implementation of the Lottie framework. This talk will introduce the technology to engineering teams, showing how to integrate the technology into their Uis. We look at why Lottie is so widely used already, and we dive into how it can be integrated into QtQuick applications, when it’s useful, and when it’s not.","persons":[{"id":4260,"full_public_name":"Becky Worledge","first_name":"Becky","last_name":"Worledge"}],"links":[]},{"id":4331,"start":"16:00","duration":"01:00","room":"C01","slug":"unifying-2d-3d-qt-quick","title":"Unifying 2D and 3D in Qt Quick","subtitle":"","tracks":[{"name":"Graphics & 3D","color":"#F8C471"}],"track":"","type":"","language":"","abstract":"","description":"Up until now, Qt Quick and it's underlying scene graph has been powered by a 2.5D renderer. This is great for implementing traditional 2D user interfaces for Desktop, Mobile, and embedded devices. However, when you want to show 3D content in your UI it has been necessary to either write your own OpenGL renderer or use an additional rendering engine. This has been sufficient when rendering a 3D scene inline, but becomes problematic when inter-mixing 2D and 3D elements. While there may currently be a few options in Qt for handling 3D content, there is no unified design tooling that can handle the mixing and matching that is necessary currently. It also currently not obvious how to use Qt Quick for more future-forward user interfaces for Augmented Reality and Virtual Reality where the final end target is not simply a 2D Window, but rather a spatial scene. As we move towards the next major release of Qt we hope to address all of these issues in Qt Quick by providing a way to define spatial content in the Qt Quick Scene Graph. This talk addresses what we have done so far and where we intend to go.","persons":[{"id":4255,"full_public_name":"Andy Nichols","first_name":"Andy","last_name":"Nichols"}],"links":[]}],"B07":[{"id":4674,"start":"17:00","duration":"00:30","room":"B07","slug":"rust-binding-qt-qml","title":"Rust binding for Qt / QML","subtitle":"","tracks":[{"name":"Qt & Technical Deep Dive","color":"#E59866"}],"track":"","type":"","language":"","abstract":"","description":"Rust is a modern system programming language that emphases on performance reliability and productivity. This talk will shortly introduce Rust, and present a project that allows to interface QML UI with a Rust backend instead of a C++ backend: https://github.com/woboq/qmetaobject-rs","persons":[{"id":4311,"full_public_name":"Olivier Goffart","first_name":"Olivier","last_name":"Goffart"}],"links":[]},{"id":4325,"start":"14:00","duration":"00:30","room":"B07","slug":"qstringview-past-present-future","title":"QStringView — Past, Present, and Future","subtitle":"","tracks":[{"name":"Qt & Technical Deep Dive","color":"#E59866"}],"track":"","type":"","language":"","abstract":"","description":"Since QStringView was added in Qt 5.10, not much has happened, and the presenter duly asks for forgiveness for having stepped away from QStringView development for two years. But he's back now, and Qt 5.14 will contain a significantly more complete QStringView (and QLatin1String) ecosystem than 5.13 did. If you do string processing with Qt, this talk is for you. After a very brief recap on QStringView's general purpose in Qt, we will look at what's new in Qt 5.14 with respect to QStringView and, time permitting, take a brief look into the near future.","persons":[{"id":4292,"full_public_name":"Marc Mutz","first_name":"Marc","last_name":"Mutz"}],"links":[]},{"id":4326,"start":"14:30","duration":"00:30","room":"B07","slug":"qml-component-design-two-way-binding-problem","title":"QML Component Design: the two-way binding problem","subtitle":"","tracks":[{"name":"Qt & Technical Deep Dive","color":"#E59866"}],"track":"","type":"","language":"","abstract":"","description":"Did you ever create QML components that both display and manipulate a state that is stored in some kind of back-end? How do you ensure a property binding set by the user of your component stays in tact? What should happen if that backed is slow, or rejects your changes? In this talk, we will explore this problem in some more detail, and demonstrate a few possible solutions that deal with the challenges raised in different ways. The goal is that at the end of this talk, you will have the tools available to make UI components that behave predictably and are intuitive to use in your applications.","persons":[{"id":4262,"full_public_name":"André Somers","first_name":"André","last_name":"Somers"}],"links":[]},{"id":4339,"start":"15:00","duration":"00:30","room":"B07","slug":"fast-c-qml-properties","title":"Fast C++-to-QML Properties","subtitle":"","tracks":[{"name":"Qt & Technical Deep Dive","color":"#E59866"}],"track":"","type":"","language":"","abstract":"","description":"Qt Quick is becoming the de-facto choice on mobile and embedded platforms. It is also widely spread in automotive and simulation software. We use Qt Quick for simulating jet planes cockpit with full indication where typical on-screen action involves up to thousands of parameters changing simultaneously. The primary language of Qt Quick is QML, which is extremely popular amongst developers and designers. It allows quick prototyping, fast development cycles, platform independence, live updates (REPL), and even more. One of the foundation pillars of QML is its property-based expressions. Properties can be seen here and there gluing UI parts together, powering UI logic, binding to each other, appearing as variables in JS code. Less often, properties serve as interlanguage communication. Properties can be stated as a bidirectional universal C++-QML (not only C++) key-value data interface accessible throughout the UI. Named packs of properties are called property maps with the vanilla exemplar named QQmlPropertyMap, which “provides a convenient way to expose domain data to the UI layer” (Qt Docs). Leveraging property maps greatly reduce the need for the C++ data layers, which can lead to more robust, maintainable, extensible products. On the other side is QQmlPropertyMap poor performance on insertion and updating operations allows no more than a few hundred properties online on desktop-class hardware. In this talk, we discuss some alternatives to QQmlPropertyMap, their trade-offs, and limits. Finally, we come to FastProperyMap which is by in order of magnitude more performant on both insertion and updates, making it suitable even for embedded devices. The audience is expected to be familiar with the Qt Meta-Object system, but no in-depth knowledge is required.","persons":[{"id":4285,"full_public_name":"Simon Davydov","first_name":"Simon","last_name":"Davydov"}],"links":[]},{"id":4340,"start":"16:00","duration":"00:30","room":"B07","slug":"verdigris-using-qt-without-moc","title":"Verdigris: Using Qt Without moc.","subtitle":"","tracks":[{"name":"Qt & Technical Deep Dive","color":"#E59866"}],"track":"","type":"","language":"","abstract":"","description":"When building an application that uses Qt, the build system is running a tool called 'moc' which parses your header and extract metadata about your code that enable features like signal and slot or property usable from QML. This talk will explain what moc does by explaining some of the internals of QMetaObject. It will continue by explaining what are the drawbacks of moc, and present an alternative: Verdigris [https://github.com/woboq/verdigris], a library that allow to use Qt without moc","persons":[{"id":4311,"full_public_name":"Olivier Goffart","first_name":"Olivier","last_name":"Goffart"}],"links":[]},{"id":4341,"start":"16:30","duration":"00:30","room":"B07","slug":"type-driven-user-interfaces-qt-c","title":"Type Driven User Interfaces with Qt and C++","subtitle":"","tracks":[{"name":"Qt & Technical Deep Dive","color":"#E59866"}],"track":"","type":"","language":"","abstract":"","description":"The template and type system of C++ can be a key success factor in distributed systems. Unfortunately, the current best practices wildly ignore this. I will teach you how Qt and the C++ type system allow us to build modern flexible user interfaces. After leveling the playing field with the introduction of strong types and event-driven architectures, the idea of a common data schema is presented to you. From this central schema we can generate all kinds of communication protocols, indexed repositories, storage formats, complex computation networks and even user interfaces. C++17 allows and helps us to achieve this in a way, that keeps the complexity low. We will conclude with a discussion of advantages and disadvantages of these techniques.","persons":[{"id":4304,"full_public_name":"Andreas Reischuck","first_name":"Andreas","last_name":"Reischuck"}],"links":[]}],"A05":[{"id":4513,"start":"15:00","duration":"00:30","room":"A05","slug":"future-qt-accelerated-development-model-ubuntu-core-snaps","title":"The Future is Qt - Accelerated Development Model with Ubuntu Core and Snaps","subtitle":"","tracks":[{"name":"Application Development 2","color":"#A569BD"}],"track":"","type":"","language":"","abstract":"","description":"","persons":[{"id":4506,"full_public_name":"Igor Ljubuncic","first_name":"Igor","last_name":"Ljubuncic"}],"links":[]},{"id":4323,"start":"14:00","duration":"00:30","room":"A05","slug":"qt-web-practical-examples","title":"Qt and the web - where are we today?","subtitle":"","tracks":[{"name":"Application Development 2","color":"#A569BD"}],"track":"","type":"","language":"","abstract":"","description":"The web and its immense success over the last 20 years had a major influence on technology. It has shaped how we serialize data, consume and provide services and how we develop HMIs. An up to date application framework needs to reflect this. This presentation will provide a survey of how this challenge is addressed by Qt. The presentation is split into three parts.\r\n\r\n1) Consuming and interfacing with web-centric services and APIs from a Qt application. Applications that download additional information from a cloud-service or upload the result of their work into such a service are today's norm. We will look into how REST/WebSocket-APIs can be used, also covering topics such as SSL, authentication, and authorization.\r\n\r\n2) Implementing services and APIs to be consumed by other - web-centric systems - with Qt. There are a number of scenarios where a Qt application is providing (web)services itself. These include Qt being used headless on an embedded system to implement the backend for a web-based HMI, Qt being used on the server to make an established application accessible to the web, or giving testers (which prefer scripting languages) access to the internals of a Qt HMI. We will look at the upcoming QHttpServer module and the QWebSocketServer module provided by Qt.\r\n\r\n3) HMI development. There are a number of scenarios where an HMI needs to run a web browser. This can either mean an HMI that is implemented using Web-technologies (by preference) or a Qt HMI needs to be run in a web browser. Scenarios include embedded devices without a display, giving remote access to HMIs and having an embedded web browser to display a web-based HMI, while the backend is implemented using Qt. We will look at Qt's webgl-streaming, how to get an application to output VNC (which can be streamed into a browser) as well as what can be done with Qt for WebAssemby. For the embedded web browser scenario we will look at the Qt WebEngine and how to integrate business logic via QWebChannel.\r\n\r\nFor each of these three areas we will look into typical scenarios/problems and how to solve them with Qt. We will highlight where Qt really shines and where additional work is left to be done.","persons":[{"id":4271,"full_public_name":"Frank Meerkötter","first_name":"Frank","last_name":"Meerkötter"}],"links":[]},{"id":4324,"start":"14:30","duration":"00:30","room":"A05","slug":"pushing-performance-qt","title":"Pushing the Performance with Qt","subtitle":"","tracks":[{"name":"Application Development 2","color":"#A569BD"}],"track":"","type":"","language":"","abstract":"","description":"When you are developing a data-intensive application or a critical system, you need to make use of all the power under the hood of the machine running it. Developers tend to overengineer the solutions so the first thing we can learn is to simplify and apply always the Occam's razor principle and don't add extra unnecessary pieces to the equation. The piece that's not there is the piece that never breaks. Let's explore different use cases and how we can do it with Qt using threads, simple data designs or tricks that make use of all the power Qt is offering to you. You can offer the user a nice and smooth experience and, at the same time, be able to do a huge amount of work under the cover.","persons":[{"id":4284,"full_public_name":"Jordi Pujol Foyo","first_name":"Jordi Pujol","last_name":"Foyo"}],"links":[]},{"id":4337,"start":"16:00","duration":"00:30","room":"A05","slug":"object-relational-mapping-qt","title":"Object-Relational Mapping with Qt","subtitle":"","tracks":[{"name":"Application Development 2","color":"#A569BD"}],"track":"","type":"","language":"","abstract":"","description":"With the increase in the complexity and the amount of data stored in embedded systems, the need in its processing directly on the device increases as well. Modern HMIs should provide the device usage statistics like manufactured pieces, material, fuel or energy consumption, error storage, operating hours, and even personalization settings for multiple users. With the touch panels attached to the device, basic data analysis tools with filtering, sorting and grouping are a natural functional requirement to have, as well as the ability to import and export this data. The use of relational database management systems (DBMS) is the common way to provide data persistence and integrity in a lot of business applications. Qt has the Qt SQL module with the most popular database plugins, and even a built-in support for the SQLite engine which is a light-weight fully functional alternative to the “big” engines like PostgreSQL or MariaDB. However, the relational databases and their query language might be intimidating at first glance. It does not have the same structure as C++, and it works in different paradigm having a set of tables that store primitive data types only. Furthermore, incorporating the database queries directly into the C++ code makes the code inflexible, less testable, adds dependencies to a specific database engine which leads to even more complexity than the good old text files. Object-relational mapping (ORM) is a programming technique intended to overcome these issues. It is a well-known technique to most of the developers in the enterprise world of Java and .NET. OR-Mapper allows to automatically map the data structures expressed in the object-oriented way into their relational table representations in a DBMS-agnostic way. Thus, the software regains the feel natural to a C++ programmer but still benefits from the relational database storage: persistence, consistency, and integrity. The OR-mappers in Java and .NET strongly rely on type introspection and annotation available in these technologies. Thanks to Qt and its Meta-Object System, these approaches can be successfully implemented in C++ as well. The actual implementation of the database layer is based on the Qt SQL module, and uses the standard SQL that allows integration with all the DBMS Qt supports out of the box. Moreover, the database layer is one of the extension points of the proposed OR-mapper, and can be replaced, for example, with a CSV, XML, or NoSQL storage. The talk explains the concepts needed to implement an OR-mapper in Qt, demonstrates a sample implementation and a real-world example. It also covers the comparison to the existing C++ analogues, Java and .NET counterparts.","persons":[{"id":4280,"full_public_name":"Dmitriy Purgin","first_name":"Dmitriy","last_name":"Purgin"}],"links":[]},{"id":4338,"start":"16:30","duration":"01:00","room":"A05","slug":"migrating-mfc-qt","title":"Migrating from MFC to Qt","subtitle":"","tracks":[{"name":"Application Development 2","color":"#A569BD"}],"track":"","type":"","language":"","abstract":"","description":"Microsoft Foundation Class Library (MFC) is a legacy C++ object-oriented library on Windows that exists since the dawn of Windows. It has been replaced lately with more up to date framework, but MFC legacy code still widely exists. While Qt and MFC are both over 25 years old, that’s where the similarity ends. Qt is actively maintained by a vibrant developer community, upgraded regularly to embrace the latest programming improvements, and expanded to cover new devices and operating systems. Qt is then a natural candidate for replacement of MFC. In this talk, we will discuss the strategy and steps to migrate an MFC legacy code base to Qt, how to map MFC code to Qt, as well as some of the traps to avoid.","persons":[{"id":4272,"full_public_name":"Nicolas Arnaud-Cormos","first_name":"Nicolas","last_name":"Arnaud-Cormos"}],"links":[]}],"A03":[{"id":4317,"start":"14:00","duration":"01:00","room":"A03","slug":"deep-dive-qt-can-bus","title":"A Deep Dive into Qt CAN Bus","subtitle":"","tracks":[{"name":"Automation","color":"#85C1E9"}],"track":"","type":"","language":"","abstract":"","description":"Controller Area Networks - CANs, for short - are widely used for the communication in cars, trucks, tractors, harvesters, construction machines and even e-bikes. When the instrument cluster in your car displays the vehicle speed or petrol level, it received CAN messages from other electronic control units (ECUs). When the driver of a harvester changes the cutting height for maize in the terminal's HMI, the terminal sends CAN messages to the other ECUs over the CAN bus. Despite the popularity of CAN, the Qt CAN bus API leads a reclusive life in the shadow of glamorous Qt modules like QML and 3D. It is time to change this. Qt 5.6 introduced the Qt CAN bus API as part of the QtSerialBus module. Qt CAN bus is a clean and simple API to connect to a CAN bus, and to send and receive CAN frames. We'll explore what Qt CAN bus offers and how to solve common CAN communication problems. We start with a simple scenario. The terminal requests the value of a parameter (e.g., the cutting height) from an ECU. The ECU receives the request in a CAN frame, reads the parameter value from its persistent storage and sends a response back to the terminal. The terminal decodes the response and displays the value in its HMI. Let us complicate the scenario a little bit. The application requests the values of all 50 parameters in a group. It writes the 50 request frames to the CAN bus in a for loop and waits for the responses. It will receive many responses but not all - and several error messages. The 50 requests made the write buffer of the CAN controller overflow. Increasing the buffer size is only a temporary solution. As every request has a response, the application could send the next request only when it has received the response to the previous request. If there is only one response every 512 requests, we configure the CAN controller to receive its own CAN frames. The application sends the next request, when it receives the frame of its previous request. The application adapts its sending rate dynamically to the load on the CAN bus. A CAN bus load of 800 frames per second is quite normal. By default, the terminal application sees all frames! Processing 200 frames in the GUI thread will already freeze the GUI. We must reduce the number of CAN frames sent from separate CAN threads to the GUI thread. We can configure the CAN controller to reject irrelevant CAN frames. The CAN threads aggregrate the CAN frames and forward a collection of CAN frames to the GUI thread at a slower rate like 4-5 times per second. If several frames with the same ID arrive in a GUI sample interval, only the last frame is taken into account. A harvester easily has more than 1000 different CAN frames. We need a code generator to produce the code for encoding and decoding all these CAN frames. The functions from QtEndian help us to generate very efficient code.","persons":[{"id":4313,"full_public_name":"Burkhard Stubert","first_name":"Burkhard","last_name":"Stubert"}],"links":[]},{"id":4328,"start":"15:00","duration":"00:30","room":"A03","slug":"introducing-qt-coap","title":"Introducing Qt CoAP","subtitle":"","tracks":[{"name":"Automation","color":"#85C1E9"}],"track":"","type":"","language":"","abstract":"","description":"CoAP is a specialized web transfer protocol for use with constrained devices and constrained networks in the Internet of Things. It targets small low-powered sensors, switches and other embedded devices, which need to be controlled or supervised remotely. CoAP is based on the wildly successful REST model and from the developer point of view, it feels very much like HTTP. The Qt CoAP module implements the client-side of the protocol. It allows leveraging C++ and Qt, for creating cross-platform CoAP applications.","persons":[{"id":4275,"full_public_name":"Alex Blasche","first_name":"Alex","last_name":"Blasche"}],"links":[]},{"id":4329,"start":"16:00","duration":"01:00","room":"A03","slug":"industrial-integration-box-qt-opc-ua","title":"Industrial integration out of the box - Qt OPC UA","subtitle":"","tracks":[{"name":"Automation","color":"#85C1E9"}],"track":"","type":"","language":"","abstract":"","description":"OPC UA is a standard for data modeling and machine to machine communication originating from the industrial automation space. Nowadays it is used in a diverse, growing set of industries. Its mission statement is to enable easy integration and interoperability between machines, components and applications of different vendors. OPC UA is an important building block of the Industry 4.0 story. This presentation will highlight how Qt fits into the picture - by presenting the Qt OPC UA API, its features and capabilities. The core goal of Qt OPC UA is to make it easy to integrate OPC UA services into Qt applications. It first entered the scene as a contribution by basysKom which became a technology preview with Qt 5.11. Since then, The Qt Company and basysKom invested significantly to mature the API and to add missing features. Most prominently are the addition of support for secure connections, service discovery, events and a brand new QML API. The presentation provides a starting point to develop OPC UA enabled Qt applications and will walk the audience through a number of scenarios and how to handle them with Qt OPC UA using both the C++ and the QML API. - Basic API concepts - Connecting to a server - Browsing - Access to nodes - Monitoring values changes - Method calls - Events The presentation provides the audience with a starting point to develop their own OPC UA enabled Qt applications.","persons":[{"id":4271,"full_public_name":"Frank Meerkötter","first_name":"Frank","last_name":"Meerkötter"}],"links":[]},{"id":4590,"start":"17:00","duration":"00:30","room":"A03","slug":"homechef-qt-consumer-electronics-demonstrator","title":"HomeChef: A QT Consumer Electronics Demonstrator","subtitle":"","tracks":[{"name":"Automation","color":"#85C1E9"}],"track":"","type":"","language":"","abstract":"","description":"The HomeChef demonstrator shows the power of Qt in converging the embedded, web and mobile worlds. The demonstrator showcases Qt applications simulating a smart cooking environment with a seamless interplay across embedded devices, web-browser and mobile phones. The demonstrator use technology components like Webassembly, MQTT, WebGL and Snips (voice assistant)\r\nThe talk highlights the learnings while developing Qt applications for MCUs and Webassembly as well as the experience in using the Qt Design Studio.","persons":[{"id":4591,"full_public_name":"Sumer Bains","first_name":"Sumer","last_name":"Bains"}],"links":[]}],"B09":[{"id":4321,"start":"14:00","duration":"01:00","room":"B09","slug":"create-plugin-qt-creator","title":"How to create a plugin for Qt Creator","subtitle":"","tracks":[{"name":"Tooling & Testing","color":"#D7DBDD"}],"track":"","type":"","language":"","abstract":"","description":"This talk will teach you how to create a Qt Creator plugin. It will start from the basics explaining how you can set up a project in Qt Creator to create a test plugin in a minute. Then focus will move on plugin design and all the code you need to implement in order to have a fully working plugin with permanent options and proper integration with the IDE. In the end you will see a real plugin in action: SIGBUILD, a plugin which notifies you when your builds are done and tracks them.","persons":[{"id":4277,"full_public_name":"Davide Coppola","first_name":"Davide","last_name":"Coppola"}],"links":[]},{"id":4334,"start":"15:00","duration":"00:30","room":"B09","slug":"practical-application-scripting-qml","title":"Practical application scripting with QML","subtitle":"","tracks":[{"name":"Tooling & Testing","color":"#D7DBDD"}],"track":"","type":"","language":"","abstract":"","description":"In my talk \"When all goes according to script\" at Qt World Summit 2015 [1] I explored the fundamentals of using the QML environment for the purpose of in-application scripting. In this follow-up, I am going to look into more practical aspects, especially on how the powerful declarative approach in QML allows very easy handling of asynchronous scripting tasks. The format will be a series of live-demos with Qt applications which either have been extended with such a scripting environment or even which have been built specifically around this capability. Similar to the original talk the goal is to show once again that QML is a versatile and powerful component for all Qt application development, above and beyond the already established use case of building advanced UIs. [1] https://resources.qt.io/videos/qtws15-when-all-goes-according-to-script-qt-application-development-kevin-krammer-kdab","persons":[{"id":4279,"full_public_name":"Kevin Krammer","first_name":"Kevin","last_name":"Krammer"}],"links":[]},{"id":4335,"start":"16:00","duration":"00:30","room":"B09","slug":"model-models-tools-making-better-behaved-models","title":"Model Models: Tools for Making Better Behaved Models","subtitle":"","tracks":[{"name":"Tooling & Testing","color":"#D7DBDD"}],"track":"","type":"","language":"","abstract":"","description":"Qt QAbstractItemModel API is used for both widgets and QML applications where it plays a central role for cases where there is a need to present larger quantities of data. For optimal performance, UI experience and to be able to use the insert, remove, move and displaced transitions on the QML ListView it is imperative that updates are signaled properly and as finely-grained as possible. But how do we deal with back-ends that don’t deliver enough data to do this? What if they just signal ‘changed’ or give us a whole new list without indicating what changed? Instead of relying on repetitive, hard-to-read and error-prone code or in the worst case relying on a model reset, I will present a generic approach leading to a simple drop-in solution to deal with data that comes in in bulk which results in proper, finely-grained updates to the model. A similar problem is providing all needed signals in case the model needs to be sorted. While a QSortFilterProxyModel does a good job doing the actual sorting, it does not provide the required signals to allow animating items moving in a QML ListView when the value of items changes or when the sort role or -column changes. In order to fix this, I will present a specialized proxy model that does enable this. Using these tools will help you make your models behave like \"model\" models.","persons":[{"id":4262,"full_public_name":"André Somers","first_name":"André","last_name":"Somers"}],"links":[]},{"id":4336,"start":"16:30","duration":"00:30","room":"B09","slug":"building-qt-application-modern-cmake-vcpkg","title":"Building a Qt Application with Modern CMake and vcpkg","subtitle":"","tracks":[{"name":"Tooling & Testing","color":"#D7DBDD"}],"track":"","type":"","language":"","abstract":"","description":"In this short talk, we will go through the process of building a Qt Quick Controls 2 application that uses a mix of C++ and QML, is built using CMake, and leverages vcpkg for 3rd party libraries.","persons":[{"id":4291,"full_public_name":"Alexandru Croitor","first_name":"Alexandru","last_name":"Croitor"}],"links":[]}]}},"2019-11-06":{"index":2,"date":"2019-11-06","rooms":{"B05":[{"id":4352,"start":"11:00","duration":"01:00","room":"B05","slug":"qt-design-studio-bridging-gap","title":"Qt Design Studio Bridging the Gap","subtitle":"","tracks":[{"name":"Graphics & 3D","color":"#F8C471"}],"track":"","type":"","language":"","abstract":"","description":"Qt Design Studio supports exporting your design directly from Sketch or Photoshop to QML. We will give a presentation of a streamlined designer-developer workflow and use Sketch to create a design that is then converted to QML and brought to action in Qt Design Studio.","persons":[{"id":4297,"full_public_name":"Thomas Hartmann","first_name":"Thomas","last_name":"Hartmann"}],"links":[]},{"id":4353,"start":"12:00","duration":"00:30","room":"B05","slug":"qtquick-autodesk-vred-next-level-immersive-design-experience-early-stage-product-design-process","title":"QTQuick in Autodesk VRED – Next-Level Immersive Design Experience in the early stage of the Product Design Process","subtitle":"","tracks":[{"name":"Graphics & 3D","color":"#F8C471"}],"track":"","type":"","language":"","abstract":"","description":"User-centered interface design increasingly gains importance in modern mobility- and product designs to provide sophisticated experiences for the end customer. Therefore, it is more important than ever to enable also designers and decision makers to get a highly realistic and fully immersive experience of their products in the early stages of the design process. This talk will give you an inside view into how QTQuick User Interfaces can be used in a 3D visualization software from Autodesk to provide new possibilities for UX/user-interface experiences in a virtual 3D environment.","persons":[{"id":4520,"full_public_name":"Markus Keller","first_name":"Markus","last_name":"Keller"},{"id":4314,"full_public_name":"Pascal Seifert","first_name":"Pascal","last_name":"Seifert"}],"links":[]},{"id":4354,"start":"13:30","duration":"01:00","room":"B05","slug":"optimizing-rendering-qt-quick-2-applications","title":"Optimizing the Rendering of Qt Quick 2 applications","subtitle":"","tracks":[{"name":"Graphics & 3D","color":"#F8C471"}],"track":"","type":"","language":"","abstract":"","description":"If you have ever wondered how Qt Quick applications are rendered to the screen, and how to use that knowledge to find and fix performance problems, then this talk is for you. Qt Quick 2 applications are notably easy to write. With just a few lines of QML code, we can create compelling, animated, fluid, 60FPS user interfaces. From time to time, however, we may face performance problems in our UI layer, especially in constrained hardware environments (mobile or embedded). In order to tackle these problems, we need to understand the foundations of Qt Quick 2’s rendering, and how to design our code in order to extract the maximum performances from the underlying hardware. And while it is true that premature optimization is the root of all evil, avoding premature pessimization is also extremely important, especially at early stages of design of a complex application. In this talk we will introduce the main principles behind profiling and optimizing the rendering of a Qt Quick 2 application. We will start by discussing how Qt Quick 2 renders a scene – namely, through its scene graph and via OpenGL calls. We will see how to gather information about how effectively Qt Quick is rendering a scene. Some of this information is available via “secret switches”, while other requires the usage of external tools, which is therefore necessary to master. Finally, we will discuss how to fix some of the most common performance problems: poor batching, excessive overdraws, fill rate limitation, and poor texture memory utilization. Practical experience with QML application is required, and some OpenGL knowledge is beneficial (but not necessary).","persons":[{"id":4257,"full_public_name":"Giuseppe D'Angelo","first_name":"Giuseppe","last_name":"D'Angelo"}],"links":[]},{"id":4355,"start":"15:00","duration":"00:30","room":"B05","slug":"whats-new-qt-3d","title":"What's new in Kuesa and Qt 3D?","subtitle":"","tracks":[{"name":"Graphics & 3D","color":"#F8C471"}],"track":"","type":"","language":"","abstract":"","description":"Since Qt 5.7, Qt 3D has been Qt's solution for 3D rendering. Kuesa is a layer that sits on top of Qt 3D. It provides a bridge between artists and application developers in order to maximize productivity and time to market.\r\n\r\nIn this talk we will go over the new features introduced in Kuesa as well as the changes and improvements that were incorporated into Qt 3D.","persons":[{"id":4268,"full_public_name":"Paul Lemire","first_name":"Paul","last_name":"Lemire"}],"links":[]},{"id":4356,"start":"15:30","duration":"00:30","room":"B05","slug":"qt-3d-node-editor-shader-generator","title":"Qt 3D Node Editor and Shader Generator","subtitle":"","tracks":[{"name":"Graphics & 3D","color":"#F8C471"}],"track":"","type":"","language":"","abstract":"","description":"More and more frameworks and tools are providing higher level of development through the use of Node Editors to generate code, behaviors or entire applications. Since Qt 5.12, Qt provides support for loading a tree of nodes and convert these to generate OpenGL GLSL shader codes for Qt 3D. This can be harnessed to create a single shader description that can then be translated into different languages. This talk will present that part of the framework, show how it is used and discuss possible ideas of how that could be extended to target completely different type of features in the future.","persons":[{"id":4268,"full_public_name":"Paul Lemire","first_name":"Paul","last_name":"Lemire"}],"links":[]},{"id":4357,"start":"16:00","duration":"00:30","room":"B05","slug":"qt-3d-q3ds-improvements-customer-pain-points-lg-jlr-ivi-project","title":"Improvements Customer Pain Points on 3D Scene","subtitle":"","tracks":[{"name":"Graphics & 3D","color":"#F8C471"}],"track":"","type":"","language":"","abstract":"","description":"With this talk, I would like to introduce which parts the Customer feels pain when creating, managing, and optimizing their 3D scenes. Also how the Professional service team can get involved and help.","persons":[{"id":4523,"full_public_name":"Kwanghyo Park","first_name":"Kwanghyo","last_name":"Park"}],"links":[]},{"id":4358,"start":"16:30","duration":"00:30","room":"B05","slug":"qskinny-new-approach-qtquick-framework","title":"QSkinny - A New Approach for a QtQuick Framework","subtitle":"","tracks":[{"name":"Graphics & 3D","color":"#F8C471"}],"track":"","type":"","language":"","abstract":"","description":"QSkinny is a framework that is built on top of the Qt scene graph and very few core classes from QtQuick. It offers a C++ and/or QML API. Besides trying to find a good combination of concepts from Qt/Widgets and Qt/Quick it is also experimenting with new ideas like a focus on vector graphics or dynamic theming. This presentation will give an overview of those ideas, the resulting architecture and a summary of how far they worked out in a real-life automotive project.","persons":[{"id":4302,"full_public_name":"Peter Hartmann","first_name":"Peter","last_name":"Hartmann"}],"links":[]}],"B09":[{"id":4360,"start":"11:00","duration":"00:30","room":"B09","slug":"qt-for-webassembly","title":"Qt for WebAssembly","subtitle":"","tracks":[{"name":"Application Development 1","color":"#EC7063  "}],"track":"","type":"","language":"","abstract":"","description":"In this talk we'll look at how to run Qt Applications on the Web using Qt for WebAssembly, which is a supported platform as of Qt 5.13. We'll cover getting started on the platform and use Qt Creator to build and deploy a demo application. We'll also look at some of the improvements shipped in Qt 5.13, such as multi-threading support, clipboard support, and support for rendering to multiple canvases. Finally we'll also look at some of the upcoming features for Qt 5.14","persons":[{"id":4270,"full_public_name":"Morten Sørvig","first_name":"Morten","last_name":"Sørvig"}],"links":[]},{"id":4361,"start":"13:30","duration":"00:30","room":"B09","slug":"mobile-business-apps-with-qt","title":"Secrets of Successful Mobile Business Apps with Qt","subtitle":"","tracks":[{"name":"Application Development 1","color":"#EC7063  "}],"track":"","type":"","language":"","abstract":"","description":"Be surprised what kind of mobile business apps you can develop with Qt QuickControls2. This session is divided into three 5 - minutes - demos live on Android and iOS, a summary of the techniques used under-the-hood and 5 minutes Q&A. All Apps are working in real-life business and are highly complex, but hiding the complexity from the user and running extremely performant: QtQuickControls 2 with Material style (plus some secrets) is the key.\r\n* App Demo \"Goods Receipt with hands-free BLE Barcode Scanner\"\r\n* App Demo \"Inpatient Care using BLE WaiterLock for fast and secure Login/Out\"\r\n* App Demo \"Outpatient Care Tour Plan working smooth in bad-coverage-areas (Offline)\"\r\n* Techniques used under the hood:\r\n+ Bluetooth LE (Barcode Scanner, WaiterLock, German Health Card Reader eGK)\r\n+ Camera to capture wounds\r\n+ Map - Navigation to next Mission using Google/Apple Maps\r\n+ JSON DataModel mapped to QObject*\r\n+ Smart Queue to survive Offline/Online changes\r\n+ Easy App - Navigation (Drawer, Bottom Toolbar)\r\n+ nearly 100% Qt C++/QML code - only some lines native (Android Java, ObjectiveC)\r\n\r\nThe world of x-platform mobile apps is increasing and perhaps you already looked at other frameworks (Xamarin, Flutter). This session makes your decision easier: Be impressed by Qt for mobile and start developing your own apps using Qt!","persons":[{"id":4307,"full_public_name":"Ekkehard Gentz","first_name":"Ekkehard","last_name":"Gentz"}],"links":[]},{"id":4362,"start":"12:00","duration":"00:30","room":"B09","slug":"feature-complete-web-browser-cross-platform-application-already-box","title":"A Feature Complete Web Browser in a Cross-Platform Application? It's Already Here, Out of the Box!","subtitle":"","tracks":[{"name":"Application Development 1","color":"#EC7063  "}],"track":"","type":"","language":"","abstract":"","description":"The variety of modules provided by Qt is so wide, a rare project uses even half of it. Except well knowns which one can meet in almost any Qt-based project - Qt Core, GUI, Test - there are some modules and add-ons which are specific to project scope. Being focused on desktop or embedded applications it could take years to get in touch with Qt Multimedia or Qt SQL. One of such relatively rarely used Qt add-ons is WebEngine. It's a powerful tool that not only allows to render the downloaded HTML but brings support for modern web technologies into your desktop application. Starting with an overview of its history we'll review general structure and architecture of the module; Available components and features and how to use them to get access to a web stored data; How to organize the interaction with a web document and get access to its DOM dynamically; Some tricks to improve the development flow and examples of combining the power of desktop with the flexibility of web on the top of Qt features. Take a chance to get a closer glance on the rare gem of Qt with usage examples from real life projects.","persons":[{"id":4305,"full_public_name":"Denis Gofman","first_name":"Denis","last_name":"Gofman"}],"links":[]},{"id":4363,"start":"11:30","duration":"00:30","room":"B09","slug":"3-tips-create-minimal-professional-documentation","title":"3 Tips to Create Minimal but Professional Documentation","subtitle":"","tracks":[{"name":"Application Development 1","color":"#EC7063  "}],"track":"","type":"","language":"","abstract":"","description":"Writing software documentation can be daunting. You know you’ve been procrastinating and you haven’t started writing documentation for your product. Cut to a few weeks before your deadline and you need to deliver some documentation with your product. At this point, a Technical Writer isn’t available. At your desk, all you can visualize is a mountain of information that you have to condense into documentation.   The bad news is: You have to start writing. However, the good news is: You don’t have to write _Everything_.   This talk aims to distill the bare minimum documentation that anyone who hates writing technical content (Engineers? Product Managers?) can still put together with minimum effort but maximum impact.","persons":[{"id":4301,"full_public_name":"Kavindra Palaraja","first_name":"Kavindra","last_name":"Palaraja"}],"links":[]},{"id":4364,"start":"14:00","duration":"00:30","room":"B09","slug":"embedded-documentation-qml","title":"Embedded Documentation with QML","subtitle":"","tracks":[{"name":"Application Development 1","color":"#EC7063  "}],"track":"","type":"","language":"","abstract":"","description":"Creating and translating software manuals is a labor-intensive matter. A wasted effort, one may argue, considering most end-users will rarely read the printed copy. This becomes even more difficult when targeting highly customized machines. Keeping manuals up to date and translated has proven to be a logistic nightmare. Using the declarative style of QML, we have embedded our manual into the package. Introspection allows the installed software to present the documentation itself while Qt tools help with the translations. This results in relevant contextual help and clear instructions right when and where the user needs it. We also provide a web-based export that is far more than a static manual. We are working towards a fully interactive knowledge base where after-sales support, technicians, and end-users can share experiences and help each other to unlock the full potential of our products.","persons":[{"id":4274,"full_public_name":"Koen Poppe","first_name":"Koen","last_name":"Poppe"}],"links":[]},{"id":4365,"start":"15:00","duration":"00:30","room":"B09","slug":"qmlqtquick-best-practices","title":"QML/QtQuick Best Practices","subtitle":"","tracks":[{"name":"Application Development 1","color":"#EC7063  "}],"track":"","type":"","language":"","abstract":"","description":"Writing QML/QtQuick applications is easy and fun right from the beginning. But once the applications grows to be complex, development pace and fun can decrease quite a bit. One part will be about general structuring and tips on how to create components, that are easy to use and maintain, but still fast to create. Some easy tricks for finding bugs and issues will be shown. Integration between C++ and QML of course is a big topic as well. And performance something not to be missed as well. Take the chance to learn many dos and don’ts from more than 8 years of QML real life experience from various projects.","persons":[{"id":4308,"full_public_name":"Günter Schwann","first_name":"Günter","last_name":"Schwann"}],"links":[]},{"id":4366,"start":"15:30","duration":"00:30","room":"B09","slug":"qt-quick-possibly-go-wrong","title":"Qt Quick - What Could Possibly Go Wrong...","subtitle":"","tracks":[{"name":"Application Development 1","color":"#EC7063  "}],"track":"","type":"","language":"","abstract":"","description":"In the last nine years basysKom has provided \"rescue services\" for numerous Qt Quick projects. This talk presents a moody retrospective - offering the audience the unique opportunity to learn from the failure of others. Once upon a time we all started our first QML project. The first impression being “wow, that was easy!”. We were full of joy, believing in the quickness and broad simplification that Qt Quick would bring into our lifes. Widgets were so done that most of us forgot that they even existed. The future was touchable, quick, bright and shiny. Qt Quick projects grew from a first small patch of code into green gardens, prospered into parks, … and sometimes they grew into wild jungles ruled by darkness; where wild roots and thick undergrowth stopped every movement, where the trees of objects grew so heavy on the memory of our targets that shipping down the river of production was as unlikely as seeing the sun at the north pole in winter times… Based on our project experience this talk will present a sightseeing tour of several close encounters for projects involving Qt Quick. It will dig for the root causes and apart from a good laugh we will provide the audience with sustainable solutions. Those can be adapted or adopted to avoid growing a jungle in the first place.","persons":[{"id":4266,"full_public_name":"Jeremias Bosch","first_name":"Jeremias","last_name":"Bosch"}],"links":[]},{"id":4368,"start":"16:30","duration":"00:30","room":"B09","slug":"working-qtquick-python-real-life-robotics-ui","title":"Working with QtQuick and Python on Real-Life Robotics UI","subtitle":"","tracks":[{"name":"Application Development 1","color":"#EC7063  "}],"track":"","type":"","language":"","abstract":"","description":"In my talk, I will describe my experience working on a real-life project with QtQuick and Python. The project I’m talking about is a graphical programming environment for a new industrial robot, which will be released end of this year. My customer chooses Python over C++ for a couple of reasons which I will explain in my talk. I have experience working with Qt for over a decade. Until last year, I have mostly worked with Qt C++, although I’m a passionate Python programmer for many years. Since I had many objections choosing Python over C++ when working Qt, I will express them in my talk and explain my findings in working on a real-life Python Qt project for over a year. Besides talking about my findings working with Python and Qt, I will also elaborate on practical and relevant topics for the Python Qt programmer with real-life examples. These topics include: Tools, workflow, and lifecycle of a Python Qt project. A way to structure a mixed Python and Qt QML project. How to do unit and GUI testing for Qt application with pytest. Clean coding practices for Python Qt applications. Debugging mixed Python and C++ applications. In the year I intensively worked with Python and Qt, especially QtQuick, I not only encountered flowers and roses, but I also found many snares. Therefore, a part of my presentation is dedicated to informing you about them. Attending this talk is highly recommended if you are Qt C++ developer considering to test-drive Qt Python, if you are Python developer interested in Qt or if you are just curious about the robot HMI project I use as a basis for the talk. Feel free to check out my articles about Qt, Python, and robotics on my blog: https://machinekoder.com/","persons":[{"id":4273,"full_public_name":"Alexander Rössler","first_name":"Alexander","last_name":"Rössler"}],"links":[]},{"id":4332,"start":"16:00","duration":"00:30","room":"B09","slug":"aim-high-make-top-quality-qt-applications","title":"Aim High: How to Make Top Quality Qt Applications","subtitle":"","tracks":[{"name":"Application Development 1","color":"#EC7063  "}],"track":"","type":"","language":"","abstract":"","description":"For an application to comply with modern UX guidelines it needs to provide an optimized experience based on the target platform and input method. It should adapt the information shown (“adaptive layouts”) based on the available screen size. It is the details that determine if an application is just ok and usable, or outstanding. Outstanding products are what we should aim for - they get referred by users and build a positive bond with your customer. To reach an outstanding application, it needs to comply with these criteria:\r\n\r\n* Optimized UI based on screen size, target platform and user input\r\n\r\n* React instantly to user input\r\n\r\n* Use animations to highlight important parts of the applications and to improve the UX\r\n\r\n* Load data asynchronously and never block the UI thread for a smooth user experience\r\n\r\n* Cache data and assets and free the cache when the user does not need it any longer\r\n\r\n* Provide offline support and sync the data when the user has internet connection again\r\n\r\n* Get notified when there is a new update available Qt provides the basis for cross-platform and cross-device functionality.\r\n\r\nBut best practices and guidelines for a combination of the above criteria are rare. So in this talk, we’ll show you how exactly we developed a real-world application fulfilling these criteria. The best practice application is optimized for Mobile Phone & Tablet, Desktop, Embedded and Web - while using a single shared code base. This talk is intended for participants with a software development background. We will guide you through the solved problems with code samples which you can use and apply in your daily job. And enables you to make Qt applications with higher quality and move your product to the next level.","persons":[{"id":4295,"full_public_name":"Christian Feldbacher","first_name":"Christian","last_name":"Feldbacher"},{"id":4264,"full_public_name":"Alexander Leutgoeb","first_name":"Alexander","last_name":"Leutgoeb"}],"links":[]}],"B07":[{"id":4369,"start":"11:00","duration":"00:30","room":"B07","slug":"testing-code-security-issues-automated-fuzzing","title":"Testing Your Code for Security Issues With Automated Fuzzing","subtitle":"","tracks":[{"name":"Tooling & Testing","color":"#D7DBDD"}],"track":"","type":"","language":"","abstract":"","description":"Writing secure code that deals with potentially untrusted data (parsers, importers, etc) is always hard since there are many potential cases to take into account. One of the techniques used to improve the security of such code is fuzzing. Fuzzing involves providing invalid or random data to a given piece of code to test its behaviour. Modern fuzzers are smart enough to understand what needs to be changed in the input to make the code go through a different code path making testing faster and more complete. oss-fuzz is a Free set of tools to make fuzzing of C/C++ code easier. It is comprised of various scripts and docker images, which, for example, have the base system libraries already compiled with the sanitizers. Coupling a fuzzer with the compiler sanitizers (asan, ubsan, msan) gives even better results since these sanitizers will make sure the code is run more strictly. In this session we'll show how to fuzz a C++ codebase, as well as give you an update on how Qt is using these tools.","persons":[{"id":4261,"full_public_name":"Albert Astals Cid","first_name":"Albert Astals","last_name":"Cid"}],"links":[]},{"id":4370,"start":"11:30","duration":"01:00","room":"B07","slug":"improving-code-using-clang-tooling","title":"Improving Your Code Using Clang Tooling","subtitle":"","tracks":[{"name":"Tooling & Testing","color":"#D7DBDD"}],"track":"","type":"","language":"","abstract":"","description":"Clang is a C/C++ compiler frontend which parses C++ source code. Since the beginning of its development, the Clang ecosystem had a strong focus on providing tooling around C++. Several tools exist, which help writing or debugging C++ or even Qt code. This talk will introduce you to several highly valuable tools backed by Clang, such as the Clang compiler frontend itself (for static analysis), the Clang static analyzer (for static analysis), clang-tidy (for static analysis, linting & refactoring of source code), clang-format (for enforcing a coding style on your code), Clang Sanitizers (dynamic analysis) and last but not least: Clazy (a compiler plugin for Clang that has additional checks for Qt code). For each tool in this presentation, we'll do a brief introduction about its capabilities and then live-demonstrate its usage on a few code examples. We'll also demonstrate how the Clang tools can be used on projects using build systems other than CMake, by applying a few tricks. Clang is available on all major platforms, thus these tools can be used freely on either Windows, Linux or macOS. (With some limitations of the Clang Sanitizers on the Windows platform.)","persons":[{"id":4265,"full_public_name":"Kevin Funk","first_name":"Kevin","last_name":"Funk"}],"links":[]},{"id":4371,"start":"13:30","duration":"00:30","room":"B07","slug":"full-stack-tracing-lttng","title":"Full-stack Tracing With LTTng","subtitle":"","tracks":[{"name":"Tooling & Testing","color":"#D7DBDD"}],"track":"","type":"","language":"","abstract":"","description":"We all love and use C++ because of its performance. But how do we actually measure the performance of an application? How do we check whether an application is CPU- or I/O bound? How do we see if our application is influenced by others running on the same system? There are many good and valid answers to these questions. Tracing certainly is a very valuable addition to everyone's toolset. It can offer in-depth insights into what a system is doing and why an application is performing in a given way. Done properly, we can use it to piece together multiple pieces of the picture: How is our hardware utilized, what is the kernel doing, what is my application doing? In this talk, we will give an introduction to LTTng, a tracing toolkit for Linux, and show how it can be applied on embedded Linux systems to get an answer to the following question: What can I do to optimize the startup time of my application? We will talk about configuring Qt and LTTng properly. We will discuss the most useful kernel trace points and demonstrate the tracing subsystem in Qt for custom user space trace points. And we will look at how to analyze the collected data in a way that doesn't make you want to pull your hair out. The contents of this talk stem from the experience of successfully optimizing automotive Qt applications on embedded Linux applications. The lessons learned apply to a much broader audience and can also be used with other tracing toolkits such as ETW on Windows.","persons":[{"id":4289,"full_public_name":"Milian Wolff","first_name":"Milian","last_name":"Wolff"}],"links":[]},{"id":4373,"start":"14:00","duration":"00:30","room":"B07","slug":"testing-patience-qt-2","title":"Testing (Your Patience) With Qt","subtitle":"","tracks":[{"name":"Tooling & Testing","color":"#D7DBDD"}],"track":"","type":"","language":"","abstract":"","description":"Testing (Your Patience) With Qt Quite a few people finds testing boring. I do, at least. Fortunately Qt delivers a comprehensive framework for automated testing of your Qt code and once you have mastered that, your future will be bright. You will be able to have a computer performing repetitive tests (they are good at repetitive things, them computers) and you will never again have to be afraid of modifying existing code. As an added bonus you will be able to deliver higher quality code faster without fearing regressions for the smallest of changes. \"Testing (Your Patience) With Qt\" will start with the basics of unit testing with Qt and how to organize your code. Next, the talk will cover basic linear testing as well as data driven testing and how to organize code for testability. Writing your code with testing in mind, increases the benefit of automated testing and you will be given a few ideas on how to do that. Eventually the talk will cover how to avoid redundant testing by mocking classes and providing stubs. Finally the talk will explain how to test classes that consumes network servers and without the need for actual servers. Attendees to this talk, will be able to go back to work and apply the Qt Testing framework and best practices thus starting improving quality immediately. This talk will not cover GUI testing.","persons":[{"id":4296,"full_public_name":"Morten Jørgensen","first_name":"Morten","last_name":"Jørgensen"}],"links":[]},{"id":4374,"start":"15:00","duration":"00:30","room":"B07","slug":"git-gerrit-working-qt","title":"Git and Gerrit For Working With and On Qt","subtitle":"","tracks":[{"name":"Tooling & Testing","color":"#D7DBDD"}],"track":"","type":"","language":"","abstract":"","description":"A basic knowledge of Git is essential if you want to apply patches back to Qt or try out a not yet released version of Qt. In this talk we're going through the most basic bits about modern software development with the code version control system Git. Beginning with the basic concepts, such as the initial setup, checking out code we will show how to manage and commit changes as well as navigate through the Git history. After having done that, we will show how to get started with the code review system in place for the Qt ecosystem, Gerrit. As part of this talk we'll discuss how to set up your Gerrit account, how to upload your SSH keys and how to configure your Git checkout to be ready to work with Gerrit. We'll do a small change on Qt module checkout, verify we did not break existing functionality, and then submit our change for review. This course is platform-agnostic, so the learned knowledge could be applied on either Windows, Linux or macOS. Course Contents - Initial setup and checkout of Git repositories - Managing and committing changes - Navigating through Git history - Collaboration via Gerrit code review and similar systems","persons":[{"id":4265,"full_public_name":"Kevin Funk","first_name":"Kevin","last_name":"Funk"}],"links":[]},{"id":4375,"start":"15:30","duration":"00:30","room":"B07","slug":"automating-gui-tests","title":"Automating Qt GUI Tests on Desktop, Web, Mobile and Embedded","subtitle":"","tracks":[{"name":"Tooling & Testing","color":"#D7DBDD"}],"track":"","type":"","language":"","abstract":"","description":"The complexity of today's user interfaces as well as continuous updates and delivery challenge software testers and engineers. While automating unit tests covers a good part of the application’s logic, testing the user interface must not be neglected. In this talk, you will learn how to tackle this task and automate the functional tests of Qt applications. We will look into the challenges ahead and cover GUI testing of Qt apps on all platforms - desktop, embedded, mobile or web - or a combination of all of that. Finally, you will also learn how to integrate automated GUI tests into continuous integration systems to leverage the full potential of automated tests and deliver high-quality software products.","persons":[{"id":4548,"full_public_name":"Reginald Stadlbauer","first_name":"Reginald","last_name":"Stadlbauer"}],"links":[]},{"id":4376,"start":"16:00","duration":"00:30","room":"B07","slug":"introducing-new-os-qt-lindows-winux","title":"Introducing a New OS for Qt: Lindows... or is it Winux?","subtitle":"","tracks":[{"name":"Tooling & Testing","color":"#D7DBDD"}],"track":"","type":"","language":"","abstract":"","description":"With the release of WSL (Windows Subsystem for Linux), the boundaries between Windows and Linux are blurring: you can now use a Bash shell on Windows and run native Linux apps straight from the shell. This talk will explore the new possibilities that WSL is opening up for Qt developers working on cross-platform apps, mainly around build and deployment infrastructure. For example: how to build Qt applications on Windows from a Bash shell script, how to use a shared Debian package repository across Windows and Linux to manage dev packages in a cross-platform way, plus tips and tricks. Examples and demos will be based on Bluescape Enterprise, a large-scale touchscreen native application, which was ported from Linux to Windows without using a single line of batch script.","persons":[{"id":4298,"full_public_name":"Romain Pokrzywka","first_name":"Romain","last_name":"Pokrzywka"}],"links":[]},{"id":4377,"start":"16:30","duration":"00:30","room":"B07","slug":"testing-profiling-qt-android","title":"Testing & Profiling Qt on Android","subtitle":"","tracks":[{"name":"Tooling & Testing","color":"#D7DBDD"}],"track":"","type":"","language":"","abstract":"","description":"In this session, we are going to learn how to test and profile our Qt application on Android.","persons":[{"id":4316,"full_public_name":"Bogdan Vatra","first_name":"Bogdan","last_name":"Vatra"}],"links":[]}],"A05":[{"id":4378,"start":"11:00","duration":"01:00","room":"A05","slug":"put-application-container-ship-many-embedded-devices","title":"Put your Application in a Container and Ship it to Many Embedded Devices","subtitle":"","tracks":[{"name":"Embedded","color":"#82E0AA  "}],"track":"","type":"","language":"","abstract":"","description":"Containers are a relatively new technology that is popular for server and cloud applications. Embedded applications can benefit from this technology by providing a reliable way to deploy applications and it's dependencies. Further, it allows you to have independent development and release cycles of different parts of your system. Qt applications, even those with a UI, can run inside a container. In this session, we will see what the advantage of such an approach is and how we can work-around some issues. We will also see how to use 3D acceleration and other hardware features from a containerized application. This hardware features can be used with similar or equal performance as \"traditional\" monolithic approaches.","persons":[{"id":4278,"full_public_name":"Valter Minute & Stefan Eichenberger","first_name":"Valter Minute & Stefan","last_name":"Eichenberger"}],"links":[]},{"id":4379,"start":"12:00","duration":"00:30","room":"A05","slug":"qt-python-embedded-systems","title":"Qt for Python on Embedded Systems","subtitle":"","tracks":[{"name":"Embedded","color":"#82E0AA  "}],"track":"","type":"","language":"","abstract":"","description":"The majority of Qt developers write applications for desktop machines. Compiling and debugging on such systems is comfortable and easy. Things get more complicated if you switch to an embedded system. You have to take care about toolchains, cross-compiling, cross-debugging, etc. Boot2Qt tries to addresses this issue but what if you could run the exact same application on an embedded system without recompiling it? Qt for Python could be the answer. It speeds up your development and allows you to prototype new features in a comfortable way. In this presentation, we will talk about what Qt for Python is, what you have to consider when using it on an embedded system and how Qt for Python can speed up your embedded development.","persons":[{"id":4278,"full_public_name":"Valter Minute & Stefan Eichenberger","first_name":"Valter Minute & Stefan","last_name":"Eichenberger"}],"links":[]},{"id":4380,"start":"13:30","duration":"00:30","room":"A05","slug":"webos-multiple-displays-using-qt","title":"webOS: Multiple Displays using Qt","subtitle":"","tracks":[{"name":"Embedded","color":"#82E0AA  "}],"track":"","type":"","language":"","abstract":"","description":"Qt already has the support for multiple displays but there are some technical hurdles to enable it on an embedded device. In this presentation Jaeyoon Jung will show how Qt helps it in webOS. In addition he is going to share additional features done for embedded multiple displays circumstance.","persons":[{"id":4309,"full_public_name":"Jaeyoon Jung","first_name":"Jaeyoon","last_name":"Jung"}],"links":[]},{"id":4381,"start":"14:00","duration":"00:30","room":"A05","slug":"qt-quick-low-end-mx6-devices","title":"Qt Quick on low-end i.MX6 devices","subtitle":"","tracks":[{"name":"Embedded","color":"#82E0AA  "}],"track":"","type":"","language":"","abstract":"","description":"This presentation showcases best practices for the development of Qt Quick HMIs on low-end i.MX6 devices. The i.MX6, together with Linux, Qt and Qt Quick are a widespread combination for the development of modern, fluid, animated touch HMIs. It is used for applications such as in-car infotainment, industrial control, portable measurement devices or medical systems. But not all products can afford a high end i.MX6 with a dual or quad core CPU and a powerful GPU. Price sensitive applications will often be implemented with more affordable variants such as an i.MX6 dual lite or even smaller. These variants are less powerful - especially in terms of GPU power. Implementing a top of the line, beautiful HMI on a small i.MX6 can be a challenge. The lecture reflects our project experience with Qt Quick on small devices, in particular, the i.MX6 dual lite and SoloX. We will demonstrate examples extracted from real life projects code suffering performance problems and show how to resolve them. The audience will get a first set of dos and don'ts, kick-starting own Qt Quick projects on low-end hardware.","persons":[{"id":4266,"full_public_name":"Jeremias Bosch","first_name":"Jeremias","last_name":"Bosch"}],"links":[]},{"id":4382,"start":"15:00","duration":"00:30","room":"A05","slug":"introduction-yocto-embedded-framework","title":"Introduction to the Yocto Embedded Framework","subtitle":"","tracks":[{"name":"Embedded","color":"#82E0AA  "}],"track":"","type":"","language":"","abstract":"","description":"The Yocto Project is a collaborative Open Source project that provides templates, tools and methods to help create custom Linux-based systems for embedded products, regardless of the hardware architecture. It was founded in 2010 as a collaboration among hardware manufacturers, open-source operating systems vendors, and electronics companies to help standardize embedded Linux development. This talk will present an introduction to the Yocto framework, starting with an overview of Yocto including its advantages and limitations as compared to other approaches for building an embedded Linux image. It will describe the major components of Yocto, including what it provides and the tools and components it offers to create embedded Linux systems. An example will be given of creating a Yocto image for the Beaglebone, a low-cost ARM development board. The steps will include building the OS image, creating an SDK for cross-compilation, and deploying the image to the board. It will introduce key tools including bitbake and its related configuration files as well as the graphical \"toaster\" tool. The development platform used will be a Linux-based desktop system. We'll wrap things up with some suggestions on how to get started using Yocto and a list of references to more information including web sites and published books. Attendees will gain a good overall understanding of what Yocto provides, the advantages it offers, and the basic process for using it to create an embedded Linux distribution. No previous experience with Yocto will be assumed, although a general understanding of embedded systems development is useful.","persons":[{"id":4282,"full_public_name":"Jeff Tranter","first_name":"Jeff","last_name":"Tranter"}],"links":[]},{"id":4383,"start":"15:30","duration":"00:30","room":"A05","slug":"create-qt-3d-application-embedded-system","title":"Create a Qt 3D application for an embedded System","subtitle":"","tracks":[{"name":"Embedded","color":"#82E0AA  "}],"track":"","type":"","language":"","abstract":"","description":"Creating a 3D application can be a complex task. OpenGL is hard to understand and complicated to setup. It gets even more complicated when embedded systems are involved. By using a pre-integrated and tested solution like Qt 3D on an Apalis iMX8 together with a 3D design tool you can speed up your 3D application development. During this talk we show some problems with 3D on embedded systems, how Qt 3D can help to avoid and work around these problems and how you can speed up your application development with the help of Kuesa or Qt 3D Studio.","persons":[{"id":4267,"full_public_name":"Stefan Eichenberger","first_name":"Stefan","last_name":"Eichenberger"}],"links":[]},{"id":4384,"start":"16:00","duration":"00:30","room":"A05","slug":"designing-ui-architecture-embedded-devices-qt-qml","title":"Designing UI Architecture for Embedded Devices with Qt and QML","subtitle":"","tracks":[{"name":"Embedded","color":"#82E0AA  "}],"track":"","type":"","language":"","abstract":"","description":"The User Interface (UI) in embedded devices these days has now evolved beyond the “skin” of a device. To develop such a complex UI, nowadays, it requires a large chunk of the development process, especially when we have large teams that need to maintain their productivity. As the complexity grows, the development process needs to adapt accordingly. It is important to maintain the UI’s modularity from the beginning of the project. This ensures that each component of the UI can be delegated to different individuals within the project and to create a healthy application ecosystem. When we talk about embedded devices, there are always dependencies between software stacks. It is really important to define each of its harnesses. With a clean UI architecture, it’s possible to deliver a well-structured UI that allows us to scale better during its development phase. Qt and QML technologies enable us to write a modular UI to increase productivity and still maintain a structured ecosystem. Managing the UI’s complexities can be much simpler if the dependencies are pushed to the edge of the UI; resulting in a cleaner, more structured UI. Additionally, enabling Live-Reloading in the development process is a key benefit to use the rapid-development-process. When the UI no longer depends on any dependencies, UI developers can work in their own space without having to wait for the other stacks to be complete. Such an environment will boost the development process by huge factors. Having a tool that helps us to maintain the modularity and the cleanness of the UI architecture will help developer to start the development process and make their lives much easier. Take an example of Neptune 3 UI from Qt Automotive Suite as a reference on how we maintain the dependencies and how we invent the user interface harnesses for each application within the whole project.","persons":[{"id":4286,"full_public_name":"Bramastyo Harimukti","first_name":"Bramastyo","last_name":"Harimukti"}],"links":[]},{"id":4385,"start":"16:30","duration":"00:30","room":"A05","slug":"qt-second-screen","title":"Qt on the Second Screen","subtitle":"","tracks":[{"name":"Embedded","color":"#82E0AA  "}],"track":"","type":"","language":"","abstract":"","description":"Companion Apps, VNC remoting, streaming WebGL to the Browser or compiling your Code to WebASM – Adding a secondary screen to your application can either extend its functionality or the physical range for users operating it. Especially for Embedded Devices, offering remote monitoring, configuration or off-site maintenance adds benefit to users used to mobile and opens quick paths for support-teams to help effectively. This talk will summarize all options Qt has to offer for these needs and the usual paradigms to follow when you design your software to reach out further.","persons":[{"id":4263,"full_public_name":"Christoph Sterz","first_name":"Christoph","last_name":"Sterz"}],"links":[]}],"C01":[{"id":4386,"start":"11:00","duration":"01:00","room":"C01","slug":"qtformcus","title":"Qt for MCUs - A Deep Dive","subtitle":"","tracks":[{"name":"Qt & Technical Deep Dive","color":"#E59866"}],"track":"","type":"","language":"","abstract":"","description":"Qt for MCUs is a new offering where we combine Qt's delightful\r\ndeclarative approach to user interface development with a new graphics\r\nengine and compiler, that's specifically designed for a low memory\r\nfootprint. In this presentation, we look at the engine and learn how it\r\nworks.","persons":[{"id":4618,"full_public_name":"Simon Hausmann","first_name":"Simon","last_name":"Hausmann"}],"links":[]},{"id":4387,"start":"12:00","duration":"00:30","room":"C01","slug":"reserved-siili-scaling-low-end-hardware","title":"High End UIs for Low End Devices","subtitle":"","tracks":[{"name":"Tooling & Testing","color":"#D7DBDD"}],"track":"","type":"","language":"","abstract":"","description":"","persons":[{"id":4514,"full_public_name":"Przemyslaw Nogaj","first_name":"Przemyslaw","last_name":"Nogaj"}],"links":[]},{"id":4388,"start":"13:30","duration":"00:30","room":"C01","slug":"qobject-deep-dive","title":"QObject Deep Dive","subtitle":"","tracks":[{"name":"Qt & Technical Deep Dive","color":"#E59866"}],"track":"","type":"","language":"","abstract":"","description":"At the heart of Qt is the QObject and the technologies that drive this. As Qt developers we love to use signals and slots, the events, the introspection and all those other features. But how do those actually work? Surprisingly few Qt developers truly understand how the QObject systems work. And by not understanding, they fail to grasp the full potential of what this can help you with. In this talk, we will dive very deep into the belly of the beast and discuss how it actually works. You will see what moc does, how it's related to QObject and why it's necessary. You will learn all there is to learn about what QObject does for your objects. We will also look at the Qt event loop and see how this is related to QObject and the Qt signals. This is necessary to understand what happens to your Qt signals. And finally, we will have a discussion about how this should modify the architecture of your code, how you should modify the way you think code to best make use of Qt. The full use of Qt allows you to code self contained components - getting away from the dreaded spaghetti code. The aim of this talk is to give the developer the necessary background knowledge to make the right decisions about Qt based designs in the code. This is an updated version of the talk from 2017, where the room could have been filled twice. If you missed it then, this is your chance.","persons":[{"id":4258,"full_public_name":"Bo Thorsen","first_name":"Bo","last_name":"Thorsen"}],"links":[]},{"id":4389,"start":"14:00","duration":"00:30","room":"C01","slug":"re-inventing-qt-core-next-decade-qt-6","title":"Re-Inventing Qt Core for the Next Decade With Qt 6","subtitle":"","tracks":[{"name":"Qt & Technical Deep Dive","color":"#E59866"}],"track":"","type":"","language":"","abstract":"","description":"","persons":[{"id":4433,"full_public_name":"Lars Knoll","first_name":"Lars","last_name":"Knoll"}],"links":[]},{"id":4390,"start":"15:00","duration":"01:00","room":"C01","slug":"the-future-of-qml","title":"The Future of QML","subtitle":"","tracks":[{"name":"Qt & Technical Deep Dive","color":"#E59866"}],"track":"","type":"","language":"","abstract":"","description":"On the way to Qt 6 the QML language and engine face major new challenges and developments. In order to scale down to smaller and smaller devices, the QML language needs to be decoupled from JavaScript and it needs to be compiled ahead of time, with as little run-time loading as possible. In order to address this, a new major version of the language is being drafted. As a result of the changes much of what is currently part of the core QML library - the JavaScript engine including its garbage collector, dynamic compilation of QML, the QML metatype system - will be moved into different modules and/or becomes optional. For simple binding expressions you don't need a full JavaScript engine, and you shouldn't have to pay for one. The talk will give an overview of the new architecture as well as the changes to the language. In particular, it will show how bindings can become more lightweight and as public API in Qt Core. It will also show what changes you will need to apply to your QML files in order to actually avoid the usage of JavaScript and to compile them ahead of time.","persons":[{"id":4254,"full_public_name":"Ulf Hermann","first_name":"Ulf","last_name":"Hermann"}],"links":[]},{"id":4391,"start":"16:00","duration":"01:00","room":"C01","slug":"qt-based-threading","title":"Qt Based Threading","subtitle":"","tracks":[{"name":"Qt & Technical Deep Dive","color":"#E59866"}],"track":"","type":"","language":"","abstract":"","description":"Computers, phones and tablets have an increasing amount of CPU cores. This means that taking advantage of threads is more and more important on everything from smaller embedded devices to very large computers. By not using the full power of the processor, we are leaving a lot of power unclaimed. Instead of setting a higher minimum device requirement, we need to embrace the threading tools and use all the computing power at hand. In Qt, there are a lot of options for building threaded applications. Everybody knows about QThread, but not everybody knows how to use this class. Qt Concurrent and QFuture and the other options are less known, but have powerful applications. With all the options, it's common for developers to be confused about which one they should choose for certain problems. So they choose one, learn that one and use it for all problems. Instead of using the proper tool for the job. And threaded application comes at a very high cost in terms of application development, debugging and maintenance. More so, if the technologies used are not the proper ones. In this talk you will see all the available Qt technologies for threaded applications, get examples of how to use them and understand why some options are better for some problems. You will also learn about the performance implications of the choices. This will give developers the necessary information to make the right choice when faced with decisions of what type of threading technology to use.","persons":[{"id":4258,"full_public_name":"Bo Thorsen","first_name":"Bo","last_name":"Thorsen"}],"links":[]},{"id":4412,"start":"09:00","duration":"00:45","room":"C01","slug":"external-keynote-2-rik-ferguson","title":"Keynote: Trend Micro","subtitle":"","tracks":[{"name":"Keynote","color":"#030056"}],"track":"","type":"","language":"","abstract":"","description":"","persons":[{"id":4440,"full_public_name":"Rik Ferguson","first_name":"Rik","last_name":"Ferguson"}],"links":[]},{"id":4413,"start":"10:00","duration":"00:15","room":"C01","slug":"customer-keynote-5-tba","title":"Customer Keynote: Caliatys - Qt & Hydrogen Mobility: Feedback on Mobile Application Design","subtitle":"","tracks":[{"name":"Keynote","color":"#030056"}],"track":"","type":"","language":"","abstract":"","description":"Hydrogen is a new energy for Mobility. Major industrials (like Air Liquide) & institutions (throughout UE, California, Japan) are investing massively to develop the ecosystem: production, transport, and stations.\r\nThanks to improved networks, the industry is emerging, and critical mass has not yet been reached. \"Digital\" plays an important role: everything is connected to help drivers refuel their cars.\r\nCaliatys, a subsidiary of Air Liquide, is leading mobile development with Qt. We'll share our feedback on the H2 mobile application, for both IOS and Android. Also, we will see how Qt concepts can help to drive a project.","persons":[{"id":4511,"full_public_name":"Nicolas Louis","first_name":"Nicolas","last_name":"Louis"}],"links":[]},{"id":4414,"start":"10:15","duration":"00:15","room":"C01","slug":"customer-keynote-6-tba","title":"Customer Keynote: Top Control - Bridging Sensor Gaps in Industrial Automation and IIOT","subtitle":"","tracks":[{"name":"Keynote","color":"#030056"}],"track":"","type":"","language":"","abstract":"","description":"Amongst many other software and hardware products for the fruit and vegetable packaging industry, TopControl provides a forklift fleet management and transport mission command and control system. To get the accurate position of each forklift in the fleet at any given point in time and information about goods currently loaded as well as their accurate loading and unloading position all forklifts are equipped with a range of sensors. Johannes will give an insight into the challenges faced during the development of one specific multi-sensor device and how Qt as a development platform helped to establish reliable communication between various software and hardware components as well as a user-friendly HMI for configuration and troubleshooting purposes.","persons":[{"id":4496,"full_public_name":"Johannes Lochmann","first_name":"Johannes","last_name":"Lochmann"}],"links":[]},{"id":4415,"start":"09:45","duration":"00:15","room":"C01","slug":"customer-keynote-unu","title":"Customer Keynote: unu - How to Build an Automotive Company From Scratch","subtitle":"","tracks":[{"name":"Keynote","color":"#030056"}],"track":"","type":"","language":"","abstract":"","description":"","persons":[{"id":4593,"full_public_name":"Mathieu Caudal","first_name":"Mathieu","last_name":"Caudal"}],"links":[]}],"A08":[{"id":4432,"start":"08:00","duration":"01:00","room":"A08","slug":"contributing-qt-breakfast-session","title":"Contributing to Qt; Breakfast Session","subtitle":"","tracks":[{"name":"Keynote","color":"#030056"}],"track":"","type":"","language":"","abstract":"","description":"Come and join discussion on the various ways how to contribute to Qt – and get some breakfast as well. We’ll first give a short introduction on how to contribute to Qt Project for example via submitting patches, fixing bugs, improving the documentation, being active in the forums or by creating new functionality. After the introduction, we’ll get a few seasoned contributors on stage to discuss about contributing to Qt.","persons":[{"id":4436,"full_public_name":"Tuukka Turunen","first_name":"Tuukka","last_name":"Turunen"},{"id":4433,"full_public_name":"Lars Knoll","first_name":"Lars","last_name":"Knoll"}],"links":[]}],"A03":[{"id":4508,"start":"14:00","duration":"00:30","room":"A03","slug":"pratical-aspects-using-qt-3d-design-studio","title":"Practical Aspects of Using Qt 3D Design Studio","subtitle":"","tracks":[{"name":"Automotive","color":"#73C6B6"}],"track":"","type":"","language":"","abstract":"","description":"","persons":[{"id":4509,"full_public_name":"Roman Leykin","first_name":"Roman","last_name":"Leykin"}],"links":[]},{"id":4344,"start":"15:00","duration":"00:30","room":"A03","slug":"intro-qt-python-write-first-data-based-application-qt-python-0-01-days","title":"Intro to Qt for Python / Write Your First Data-based Application with Qt for Python in 0.01 days","subtitle":"","tracks":[{"name":"Python","color":"#cc6699"}],"track":"","type":"","language":"","abstract":"","description":"Handling data is a fun task, but it can easily become a messy one. Thankfully Python helps us to solve most of our problems, due to the large amount of modules that improve our workflow, but having a set of scripts that can help you on different processes is not the best way to distribute or allow other users to use them. Getting value from your code base usually translates into adapting it into a more easy-to-understand process including: allowing to select input files, change parameters, save plots, etc. This new layer of difficulty is more extreme if the end-user of your script is someone without Python or programming knowledge. In this talk, you will learn how to create data-oriented graphical user interfaces, to make algorithms easier to use.","persons":[{"id":4281,"full_public_name":"Dr. Cristián Maureira-Fredes","first_name":"Dr. Cristián","last_name":"Maureira-Fredes"}],"links":[]},{"id":4345,"start":"15:30","duration":"00:30","room":"A03","slug":"bring-c-project-python-land","title":"How to bring your C++ project to Python land","subtitle":"","tracks":[{"name":"Python","color":"#cc6699"}],"track":"","type":"","language":"","abstract":"","description":"There has been always efforts to provide Python bindings for many popular C++ libraries and frameworks. This binding process is a complex task, and there has been many tools that tried to achieve t in different ways. Due to the complexity of some libraries, one needs to wisely choose the elements that will form this entire process. In the case of Qt, after a proper study, it became apparent that a custom solution was required, and this led to the creation of Shiboken, which is the bindings generator tool behind the Qt for Python project. In this talk, you will learn how to get started with many binding generation tools, but most importantly we will go step-by-step on how to start your own binding project using Shiboken.","persons":[{"id":4281,"full_public_name":"Dr. Cristián Maureira-Fredes","first_name":"Dr. Cristián","last_name":"Maureira-Fredes"}],"links":[]},{"id":4346,"start":"16:00","duration":"00:30","room":"A03","slug":"utilizing-shiboken-enhance-qt-python-application","title":"Utilizing Shiboken to Enhance your Qt for Python Application","subtitle":"","tracks":[{"name":"Python","color":"#cc6699"}],"track":"","type":"","language":"","abstract":"","description":"Shiboken is the Python binding generator used to create the PySide module of Qt for Python, enabling users to access the power of the Qt C++ API from Python. For many Python developers, the PySide module provides everything they need to create a great Qt-based application, but others may have needs that require generating their own bindings. For instance, they may have an existing C++ library or a custom Qt-derived widget they would like to access from Python, or they would like to use a 3rd party Qt-derived library such as QWT that is not part of PySide. There are several tools available to create Python bindings, but utilizing Shiboken, which has been specifically designed to work with Qt and is part of Qt for Python, can potentially expedite the process when working on Qt-based applications. This talk will review how users can use Shiboken to enhance their Qt for Python applications, including the situations listed above and providing a means to extend Qt-based C++ applications with Python scripting. Limitations and comparisons to SIP, the binding generator for PyQt, will be reviewed. Shiboken may not be the best solution for all situations, but the intent is to increase awareness of its capabilities beyond being the generator of PySide.","persons":[{"id":4276,"full_public_name":"Sharon Woods","first_name":"Sharon","last_name":"Woods"}],"links":[]},{"id":4347,"start":"16:30","duration":"00:30","room":"A03","slug":"testing-pysidepyqt-code-easily-using-pytest-framework","title":"Testing PySide/PyQt Code Easily Using the Pytest Framework","subtitle":"","tracks":[{"name":"Python","color":"#cc6699"}],"track":"","type":"","language":"","abstract":"","description":"Both PySide and PyQt allow rapid prototyping and development of Qt applications using the Python programming language. However, the Qt Test framework is focused on C++, and only a subset of its functionality is available in Python. Together with the \"unittest\" module in the Python standard library (which exposes a heavyweight, xUnit-like API), this can make tests unnecessarily cumbersome to write. The pytest framework coupled with the pytest-qt plugin allows writing tests for Qt/Python code in a much more straightforward and fun way. It exposes the QTestLib API, but also adds various high-level functionality with an API which is more suitable for Python code. This talk will give the audience a short introduction to pytest and explain how to test Python/Qt code using the pytest-qt plugin. It will also take a quick look at other useful pytest plugins which can be combined with pytest-qt.","persons":[{"id":4290,"full_public_name":"Florian Bruhin","first_name":"Florian","last_name":"Bruhin"}],"links":[]},{"id":4348,"start":"11:00","duration":"00:30","room":"A03","slug":"introduce-certified-safety-critical-cockpit-controler-based-hypervisor-linux-android-new-generation-vehicles","title":"How to introduce a certified safety critical Cockpit Controler based on Hypervisor and Linux / Android in to the new generation of vehicles","subtitle":"","tracks":[{"name":"Automotive","color":"#73C6B6"}],"track":"","type":"","language":"","abstract":"","description":"\"The future of the automotive industry is more inclined toward computer oriented innovations such as mobility, connectivity, and autonomous driving. Since these advanced technologies involve the integration of software and hardware components, there is a need for isolation of software interference. Virtualization for embedded systems is the key enabling technology in addressing this challenge. The hypervisor is the underlying component of the virtualization technology, being responsible for the scheduling of the heterogeneous virtual machines (VMs) with different real-time constraints (e.g. AUTOSAR, Android). Car connectivity and the IoT revolution are rapidly growing markets. This technology supports advanced safety features and improves user experience. However, the digitalization of cars creates a threat of car hacking. Therefore, the type 1 hypervisor is expected to register the fastest growth in the coming years for passenger car applications. Type-1 hypervisors provide strong separation, ensuring freedom from interference within mixed-criticality systems. Virtualization also enables secure partial software update, acting as an extra layer of security beyond software platform-specific hardening. OpenSynergy presents a certified safe Cockpit Controler Solution showing how Linux or Android may use within safety critical environment — enabling the comprehensive open-source ecosystem while ensuring security-critical and performance requirements. (Several SOP using this concept will be in 2019 / 2020.) This OpenSynergy – Qt Solutions provides some insights about the advantages: • Access to the Linux / Android driver and application world. • Reduce the BSP and driver development efforts. • Support the VIRTIO standard. • Provides a TÜV certified Safe Instrument Cluster approach based on Linux. • Providing the Information where the driver needs it. \"","persons":[{"id":4300,"full_public_name":"Tero Salminen","first_name":"Tero","last_name":"Salminen"}],"links":[]},{"id":4349,"start":"11:30","duration":"00:30","room":"A03","slug":"qt-university-education-automotive-engineers","title":"Qt in University Education for Automotive Engineers","subtitle":"","tracks":[{"name":"Automotive","color":"#73C6B6"}],"track":"","type":"","language":"","abstract":"","description":"University education bears a high responsibility to prepare students for the requirements of modern computer systems. As an university of applied science, we are highly committed to teach our students the fundamentals of engineering and the handling of the industry’s leading toolsets. We would like to show a project where we use Qt as a teaching tool to visualize a MATLAB/Simulink simulation in real-time and another project where students use Qt itself to gain experience in UI-Design by developing mixed reality computer games. For the purpose of teaching the details of connected automotive vehicle functions, we have developed a modular learning management system which consists of multiple electrical control units like those of a modern car. Students can program these systems in C/C++ or by developing model driven software based on MATLAB/Simulink. The later approach is extremely interesting because it represents a very common way of professional software engineering in the automotive industry. Models can be simulated in soft or hard real-time prior to transferring it to the target platform. MATLAB/Simulink provides different dashboard elements for user input and output during simulation. To overcome the lack of flexibility with these simple widgets we combine MATLAB/Simulink for computational purposes and Qt Quick for visual input and output. This is done by extending the well-established Model-View-Controller (MVC) approach by splitting it up into two separately running processes (MATLAB/Simulink based model and Qt based UI) with a synchronized model database between both processes. The synchronization is done via serialized classes and UDP/IP transmission. In our particular example, we simulate the hardware behavior of our modular learning management system with a MATLAB/Simulink model and visualize the optical behavior and its inputs with a Qt Quick based UI to provide an utmost realistic test environment. By doing so, we are combining two leading technologies of the industry to increase their performances even more. To support and motivate our students in the field of modern UI development, we created a mixed reality platform to embed real-objects into the virtual-world and make them interact with each other. In comparison to other AR approaches, we wanted to make the real-world objects more interactive by mounting them on wheel-based mini robots and equip them with Wi-Fi interfaces for communication. For visualization of the virtual-world and tracking of the real-world objects we experimented with different projector-camera based approaches. The decreasing prices for large scale touch screens brought up the idea to use a 65\" multipoint touch screen as a table and place the robots on top of the screen. The touch functionality is used to track the robots’ positions and the display can be used to show a virtual world below them. As a reference implementation, we decided to create a mixed reality version of the popular tabletop game \"Star Wars X-Wing\". Graphics are visualized entirely in Qt Quick and Qt3D to combine 2D and 3D animations to highlight certain events, show game statistics and instructions in completely new ways.","persons":[{"id":4293,"full_public_name":"Torsten Wylegala","first_name":"Torsten","last_name":"Wylegala"}],"links":[]},{"id":4350,"start":"12:00","duration":"00:30","room":"A03","slug":"chargepoint-ev-charging-stations-utilizing-qt-webassembly-accelerate-development","title":"ChargePoint EV Charging Stations: Utilizing Qt Webassembly to Accelerate Development","subtitle":"","tracks":[{"name":"Automotive","color":"#73C6B6"}],"track":"","type":"","language":"","abstract":"","description":"Webassembly powered ChargePoint EV Charging Station Demo at http://stationui-demo.charge-point.co Large embedded devices are difficult to develop for, as their size and availability make it hard to share or develop with remote teammates, offsite translation firms, UX designers, executives, Product Managers and Business Developers located in different countries.  ChargePoint utilizes Qt Webassembly to provide a live online demo of the charging station's UI, hosted on AWS S3, allowing quick UX review from other teams, training purposes, enabling a demo sales can utilize for prospective customers, and make it accessible to outside parties located anywhere in the world. This talks will also cover: Common QML with Multiplatform C++ backends (webassembly, desktop and embedded) Qt Webassembly limitations and workarounds Simulation scenarios via QStateMachine AWS S3 static hosting of Qt Webassembly Correct window size via launcher window and popup window","persons":[{"id":4287,"full_public_name":"Matthew Hungerford","first_name":"Matthew","last_name":"Hungerford"}],"links":[]},{"id":4351,"start":"13:30","duration":"00:30","room":"A03","slug":"ecu-development-workflow-qt-yocto","title":"ECU Development Workflow with Qt & Yocto","subtitle":"","tracks":[{"name":"Automotive","color":"#73C6B6"}],"track":"","type":"","language":"","abstract":"","description":"Bringing Qt to a graphical embedded device (ECU) is “mostly” easy. Creating a workflow that coordinates the multi-team development of a full ECU software is a completely different story, though. The scenario I am discussing in this talk has the following characteristics: There is an actively developed hardware and board support package, there is a platform team to provide a development framework for applications as well as applications for base services, and there are (in-house & external) application teams that work on top of everything. The whole development approach follows an agile setup. This talk focuses on how Yocto and Qt can be used to create and control such a workflow. The complexity of such a project not only lies in the team setup but also in the integration of the individual software parts. Having several graphical applications requires a window compositor as a base application. Developers need the compositor in order to develop and test their applications. As the BSP and the base software is constantly being developed it is necessary to coordinate the development of the application and the platform as SDK (BSP + base software). Incremental integration of the ECU software allows subsequent development teams to create their software. My focus lies on the different technologies that can make such a development setup work. In my talk, Yocto is the central technology that coordinates the development and integration workflow. It is used to generate development and production images for different stages of the development process (application developers, testers, integration testers). The application development is based on the Yocto “Standard SDK” and the (unmodified) QtCreator as default IDE. With the help of QtCreator Kits, the Yocto SDKs can be used without any manual configurations. Reflecting on my project experiences, I will show how several open source technologies can be used to create a well-fitting workflow that solves a very complex development problem.","persons":[{"id":4303,"full_public_name":"Andreas Cord-Landwehr","first_name":"Andreas","last_name":"Cord-Landwehr"}],"links":[]}]}}}}}
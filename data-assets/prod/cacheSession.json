[
    {
        "abstractText": "",
        "description": "Much of what will happen in the next 30 years is inevitable, driven by technological trends that are already in motion. Some of what is coming may seem scary, like ubiquitous tracking, screens everywhere, virtual reality in your bedroom, or robots replacing humans. Kevin Kelly outlines what is inevitable and argues that we should embrace these changes, rather than outlaw, or slow them down, because by embracing with vigilance we gain their maximum benefits and least harms.",
        "endTime": "09:40",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 30,
        "presenter": [
            "1114"
        ],
        "room": 1,
        "sessionDay": 1,
        "sessionId": 1353,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "2"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1909:10",
        "startTime": "09:10",
        "subtitle": "",
        "title": "The Inevitable Digital Futures"
    },
    {
        "abstractText": "",
        "description": "Industry leaders present their insights on the exponential possibilities of tracking.",
        "endTime": "10:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 75,
        "presenter": [
            "1690",
            "1548"
        ],
        "room": 4,
        "sessionDay": 1,
        "sessionId": 1734,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "2"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1909:40",
        "startTime": "09:40",
        "subtitle": "",
        "title": "Inspiration & Insight – Spotlight Talks – Tracking"
    },
    {
        "abstractText": "",
        "description": "Industry leaders present their insights on the exponential possibilities of  interfaces, virtual reality and the like.",
        "endTime": "10:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 75,
        "presenter": [
            "1527",
            "1362",
            "1322"
        ],
        "room": 4,
        "sessionDay": 1,
        "sessionId": 1733,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "2"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1909:40",
        "startTime": "09:40",
        "subtitle": "",
        "title": "Inspiration & Insight - Spotlight Talks - Interfaces (VR)"
    },
    {
        "abstractText": "",
        "description": "Industry leaders present their insights on the exponential possibilities of Multiscreen.",
        "endTime": "10:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 75,
        "presenter": [
            "1315"
        ],
        "room": 4,
        "sessionDay": 1,
        "sessionId": 1732,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "2"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1909:40",
        "startTime": "09:40",
        "subtitle": "",
        "title": "Inspiration & Insight - Spotlight Talks - Multiscreen"
    },
    {
        "abstractText": "",
        "description": "Industry leaders present their insights on the exponential possibilities of access everywhere.",
        "endTime": "10:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 75,
        "presenter": [
            "1681",
            "1326",
            "1325",
            "1304"
        ],
        "room": 4,
        "sessionDay": 1,
        "sessionId": 1729,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "2"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1909:40",
        "startTime": "09:40",
        "subtitle": "",
        "title": "Inspiration & Insight - Spotlight Talks - Access Everywhere"
    },
    {
        "abstractText": "",
        "description": "",
        "endTime": "10:35",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 50,
        "presenter": [
            "1326",
            "1325"
        ],
        "room": 1,
        "sessionDay": 1,
        "sessionId": 1530,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "2"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1909:45",
        "startTime": "09:45",
        "subtitle": "",
        "title": "How the OneDrive Mobile Team uses Qt"
    },
    {
        "abstractText": "",
        "description": "",
        "endTime": "10:50",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 65,
        "presenter": [
            "1304"
        ],
        "room": 1,
        "sessionDay": 1,
        "sessionId": 1694,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "2"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1909:45",
        "startTime": "09:45",
        "subtitle": "",
        "title": "Qt & Ubuntu"
    },
    {
        "abstractText": "",
        "description": "Automation promises to free us from routine tasks - to leave the low-level details of whatever it is we’re doing to the computers while we humans pop up a level and focus on the ‘big picture.’  Using examples from the airline cockpit, semiautonomous cars, and other applications, NASA scientist Steve Casner discusses why dividing work between humans and computers can be far more challenging than it seems.",
        "endTime": "11:40",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1124"
        ],
        "room": 1,
        "sessionDay": 1,
        "sessionId": 1495,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "2"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1911:15",
        "startTime": "11:15",
        "subtitle": "",
        "title": "The Paradox of Automation: Finding The Right Combination of Humans and Technology"
    },
    {
        "abstractText": "",
        "description": "Built with Qt, AMD introduced a brand new user experience and interface for their graphics control panel that has been around for over 10 years. Andrej discusses the process and the results of AMD using Qt to create this new experience.",
        "endTime": "12:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1527"
        ],
        "room": 1,
        "sessionDay": 1,
        "sessionId": 1529,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "2"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1912:00",
        "startTime": "12:00",
        "subtitle": "",
        "title": "AMD and Qt"
    },
    {
        "abstractText": "",
        "description": "Internet of Things (IoT) is a very broad term and depending on the industry type demands a variety of requirements to be fulfilled. To provide the necessary overview, industry cases in the IoT domain are presented and their unique features and communication details examined. This catalogization shall then be used to define the IoT term in the context of Qt. It includes a matching of Qt's current and future capabilities within the domain. Technical examples are presented to underline these capabilities. The target audience is architects and business people.",
        "endTime": "13:10",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1039"
        ],
        "room": 6,
        "sessionDay": 1,
        "sessionId": 1156,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "3",
            "12",
            "8"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1912:45",
        "startTime": "12:45",
        "subtitle": "",
        "title": "Qt & the Internet of Things (IoT) - Do they fit together?"
    },
    {
        "abstractText": "",
        "description": "Rimac Automobili Ltd. is a technology company which focuses on the development and production of high-performance electric vehicles, powertrains and battery systems.\r\n\r\nAfter several years of development, the company has unveiled the world’s first fully electric supercar – the Concept_One, at the 2011 Frankfurt Auto Show.\r\n\r\nWith more than a 1000 HP and four electric motors, the Concept_One is an exceptional car, combining the revolutionary approach to vehicle dynamics – All Wheel Torque Vectoring (AWTV) with advanced battery technology and many other creative features.\r\n\r\nThe technology inside the Concept_One has been developed in-house as the goal of Rimac team was to raise the bar in every aspect of the vehicle. Therefore they needed to start with a clean sheet of paper and design all components with the ultimate goal in mind.\r\n\r\nFor the purpose of Concept_One, the team has developed one of the worlds most advanced in-vehicle infotainment systems. At its hart, infotainment is powered by Qt. The talk will give an insight into the process how this system was developed and how Qt made it possible.",
        "endTime": "13:10",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1362"
        ],
        "room": 5,
        "sessionDay": 1,
        "sessionId": 1363,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "6"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1912:45",
        "startTime": "12:45",
        "subtitle": "",
        "title": "Qt Inside the World’s First Fully Electric Supercar"
    },
    {
        "abstractText": "",
        "description": "QtSerialBus is a new Qt module, introduced as a technical preview in Qt 5.6.0. It supports two serial interface protocols that are commonly used on embedded systems: CAN bus and Modbus. This talk will introduce QtSerialBus, starting with background on the CAN bus and Modbus interface protocols, and the currently supported platforms, drivers, and hardware. The Qt Serial Bus C++ APIs will be presented and some code examples shown, as well as a demonstration of some sample applications running. Areas of possible future work will be discussed as well as references to more information.",
        "endTime": "13:10",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1066"
        ],
        "room": 3,
        "sessionDay": 1,
        "sessionId": 1157,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "4",
            "16"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1912:45",
        "startTime": "12:45",
        "subtitle": "",
        "title": "Qt Serial Bus: Using Modbus and CAN bus with Qt"
    },
    {
        "abstractText": "",
        "description": "UI has been with us from the beginning of the computer and will be with us far into the future. It is what we interact with in our daily lives and it will continue to change our lives for the better. Andrej discusses UI with a brief history, moving right into the future of what VR and AR has in store and the exciting challenges we will face as developers.",
        "endTime": "13:10",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1527"
        ],
        "room": 2,
        "sessionDay": 1,
        "sessionId": 1528,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1912:45",
        "startTime": "12:45",
        "subtitle": "",
        "title": "The Future of UI"
    },
    {
        "abstractText": "",
        "description": "BEP Marine manufactures a range of high quality electrical solutions designed for marine and recreational vehicles. CZone, their market leading digital switching technology, utilizes the industry standard NMEA2000 network to control all electrical systems on the vessel or vehicle. Dedicated touch screens and compatible Garmin, Furuno or Navico multifunction displays offer single touch control over hundreds of individual circuits. CZone brings the convenience of home automation to boats and recreational vehicles designed for the harsh marine and outdoor environments.\r\n\r\nOne of the biggest challenges for the Auckland based engineering team is developing and maintaining software for the many different platforms. Software for micro controllers, embedded Linux, mobile and desktop platforms all need to be synchronized and kept to a high standard. This is where Qt is able to provide the team with the advantage. Embedded, mobile and desktop platforms are able to share the same source code drastically reducing the amount of work (and mistakes!).\r\n\r\nCurrently the team is updating the user interface across the three platforms using Qt to provide a consistent experience for consumers. This presentation will explore the user interface development process from artwork to implementation for a few key user interface elements. Take a look at a cross platform build and deploy process. How QML enables rapid feedback from the stakeholders, and custom components rendered with OpenGL give full control over the graphics hardware. Various rendering methods are demonstrated and compared.\r\n\r\nWith 6 battery banks, 172 DC circuits, 35 AC circuits, two generators, two shore power connections, four battery chargers and an inverter, managing the on board systems on the flagship Riviera 77 motor yacht is a complex task! This talk aims to give you a glimpse into how CZone uses Qt to make it easy.",
        "endTime": "13:40",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1315"
        ],
        "room": 6,
        "sessionDay": 1,
        "sessionId": 1314,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "16",
            "19"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1913:15",
        "startTime": "13:15",
        "subtitle": "",
        "title": "Smooth sailing with OpenGL ES and QML"
    },
    {
        "abstractText": "",
        "description": "As from QtCreator 3.2, BMW Car IT adapted the IDE to function as main integration of the coding and debugging process. Required changes on the plugin API as lack of future requirements. The current system needed to be tied to a specific Linux version and a customized version of the IDE need to be released each time, This process was time consuming and did every release dependent of been generated in-house.\r\n\r\nWith the advent of Qt LTS and changes of plugin system on most recent Qt Creator versions, was time to start to foresee the possibility to use a plugin only that can be used by any deployed Qt Creator version in any Linux distribution.\r\n\r\nWith final developer as the main target user, simplicity on the install and usage process are main priority raising the current technical limitations on our current deployment side, such as:\r\n\r\n \tUsage of a specific Linux  platform against allow the developer use their own distribution\r\n \tAdapt the plugin to be used on current available qt-creator releases instead of custom one\r\n \tEasy install process on the toolchain and plugin\r\n \tControl of external debuggin\r\n \tIntroduce non regular functions the the visual plugin part, like sdk / toolchain package manipulation\r\n \tAllow a code completion for the toolchain software\r\n\r\nIn a solving pattern, some of current Qt solutions are available to use, like qt framework installer to the easy deployment or the new parser system based on clang, but still limited like the necessity of compile the plugins inside a built code of qt-creator, or lack of proper plugin visual interface customization.\r\n\r\nThe talk will show the current status of the project and how we're planning to address this unanswered issues.",
        "endTime": "13:40",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1384"
        ],
        "room": 5,
        "sessionDay": 1,
        "sessionId": 1383,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "6"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1913:15",
        "startTime": "13:15",
        "subtitle": "",
        "title": "Qt Creator as BMW Car IT Automotive IDE"
    },
    {
        "abstractText": "",
        "description": "This session will describe how to build Qt based IoT solution for digital signage or kiosk applications using Qt on Ubuntu Core. ",
        "endTime": "13:40",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1345",
            "1341"
        ],
        "room": 4,
        "sessionDay": 1,
        "sessionId": 1305,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "1",
            "21",
            "12",
            "17"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1913:15",
        "startTime": "13:15",
        "subtitle": "",
        "title": "Building Secure and Maintainable IoT Solutions with Qt and Ubuntu Core"
    },
    {
        "abstractText": "",
        "description": "Medical technology is quickly advancing into the mobile realm where rather than patients being prescribed medicines, they are prescribed apps to help provide additional data and track various health related measurements. Along with these apps, small electronic devices are rapidly being developed to provide additional sensor-acquired information that can be affordably obtained by either the physician or the patient. Clarius Mobile Health is developing a revolutionary new ultrasound device which wirelessly connects to custom mobile apps developed for smartphones and tablets. Where traditional ultrasound devices are cart based or at minimum, the size of a laptop, we’ve scaled down the architecture to a device that weighs less than 600 grams, but still provides the high-end image quality that is expected from traditional and costly ultrasound units. The Clarius ultrasound device connects through both Bluetooth Low Energy and WiFi to provide connection information and transmit ultrasound images at over 30 frames per second. To dramatically simplify the development and deployment of the software, Clarius is relying on the Qt toolkit to provide everything from a QML based GUI, internal core components, as well the new Qt Bluetooth framework which encapsulates the very specific mobile APIs. By not having to rely on native Swift and Java development, the development timeline has been rapidly shortened. To help with testing the core functionality, GUI, and even Bluetooth, the software is easily compiled for a Linux desktop environment to provide an elegant mechanism to develop and test prior to deployment on the mobile architectures. By creating a device which is much smaller than traditional ultrasounds, and employing Qt as a base framework for the mobile app development, Clarius is on track to put ultrasound devices in the hands of physicians and patients that would have never previously been able to use or afford such an important tool in the health sector. It has been said many years ago that ultrasound will become the stethoscope of the future, and Clarius is now leading the way to achieve that goal.",
        "endTime": "13:40",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1061"
        ],
        "room": 2,
        "sessionDay": 1,
        "sessionId": 1176,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "12",
            "13"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1913:15",
        "startTime": "13:15",
        "subtitle": "",
        "title": "Replacing the Stethoscope with Ultrasound"
    },
    {
        "abstractText": "",
        "description": "4tiitoo is a leading company in natural interaction for workstations, VR &amp; AR headsets, control panels, HUDs, CAVEs, Powerwalls, and IoT devices.\r\n\r\n4tiitoo’s software platform NUIA controls everyday devices and applications in a consistent and natural way based on inputs like gaze, gestures and speech. It predicts users' intentions to enable devices to act automatically and intelligently.\r\n\r\nThe NUIA Software and SDK is created using C++/Qt and QML. It connects and processes sensor-based data from eye trackers, 3D cameras, gesture wearables, microphones, mobile devices, AR/VR headsets, IoT devices, and measuring sensors. NUIA enables any Windows 7/8/10 application or website to be controlled via these next generation sensors, with currently more than 100 applications and websites supported.\r\n\r\nA special use case for developers is the NUIA IDE Booster for the Qt Creator. This NUIA Extension enables users to control the Qt Creator with their eye tracking equipped computers (e.g. with the Tobii EyeX peripheral or built-in in the MSI GT72S notebook). NUIA uses the eye tracking data to provide more efficient and convenient ways to control the IDE - resulting in a performance boost. Features of the NUIA IDE Booster for the Qt Creator include:\r\n\r\n● Fluid resizing: Enlarge the panel you look at with one keypress to see the debug output or source code maximized\r\n\r\n● Mouse teleporter: Sends your mouse cursor automatically to buttons and areas you want to trigger and back to the last point of action when you look back\r\n\r\n● Automatic scrolling: Just read a web page and NUIA will know when to scroll. Scrolling speed is adjusted to your reading pace.\r\n\r\n● Quick app switching: Switch between all open apps in the blink of an eye\r\n\r\n● List selection: Directly access even small list items. Small lists can trigger helper menu for quick selection\r\n\r\n● Gaze buttons: Trigger buttons without touching the mouse. Frequently used buttons can be configured for automatic gaze clicking\r\n\r\n● Directed search: Directly search the content you work on. Crtl + f triggers the search in the panel you look at\r\n\r\n● Workflow automation: Trigger custom workflows by gaze. Buttons in NUIA Menu can be configured by you\r\n\r\n● More information on the IDE Booster at https://store.nuia.com/categories/installer/extensions/nuia-ide-edition or http://www.4tiitoo.com\r\n\r\nThe talk introduces the possibilities of gaze control in general and the Qt Creator in detail and highlights advantages and best practices of eye interaction.",
        "endTime": "13:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1701"
        ],
        "room": 1,
        "sessionDay": 1,
        "sessionId": 1165,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "1"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1913:30",
        "startTime": "13:30",
        "subtitle": "",
        "title": "Enabling Devices to Act Automatically and Intelligently through Eye Interaction"
    },
    {
        "abstractText": "",
        "description": "4tiitoo is a leading company in natural interaction for workstations, VR &amp; AR headsets, control panels, HUDs, CAVEs, Powerwalls, and IoT devices.\r\n4tiitoo’s software platform NUIA controls everyday devices and applications in a consistent and natural way based on inputs like gaze, gestures and speech. It predicts users' intentions to enable devices to act automatically and intelligently.\r\nThe NUIA Software and SDK is created using C++/Qt and QML. It connects and processes sensor-based data from eye trackers, 3D cameras, gesture wearables, microphones, mobile devices, AR/VR headsets, IoT devices, and measuring sensors. NUIA enables any Windows 7/8/10 application or website to be controlled via these next generation sensors, with currently more than 100 applications and websites supported.\r\nA special use case for developers is the NUIA IDE Booster for the Qt Creator. This NUIA Extension enables users to control the Qt Creator with their eye tracking equipped computers (e.g. with the Tobii EyeX peripheral or built-in in the MSI GT72S notebook). NUIA uses the eye tracking data to provide more efficient and convenient ways to control the IDE - resulting in a performance boost. Features of the NUIA IDE Booster for the Qt Creator include:\r\n- Fluid resizing: Enlarge the panel you look at with one keypress to see the debug output or source code maximized\r\n- Mouse teleporter: Sends your mouse cursor automatically to buttons and areas you want to trigger and back to the last point of action when you look back\r\n- Automatic scrolling: Just read a web page and NUIA will know when to scroll. Scrolling speed is adjusted to your reading pace.\r\n- Quick app switching: Switch between all open apps in the blink of an eye\r\n- List selection: Directly access even small list items. Small lists can trigger helper menu for quick selection\r\n- Gaze buttons: Trigger buttons without touching the mouse. Frequently used buttons can be configured for automatic gaze clicking\r\n- Directed search: Directly search the content you work on. Crtl + f triggers the search in the panel you look at\r\n- Workflow automation: Trigger custom workflows by gaze. Buttons in NUIA Menu can be configured by you\r\n- More information on the IDE Booster at https://store.nuia.com/categories/installer/extensions/nuia-ide-edition or http://www.4tiitoo.com\r\nThe talk introduces the possibilities of gaze control in general and the Qt Creator in detail and highlights advantages and best practices of eye interaction.",
        "endTime": "14:05",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 20,
        "presenter": [
            "1701"
        ],
        "room": 6,
        "sessionDay": 1,
        "sessionId": 1728,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "12"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1913:45",
        "startTime": "13:45",
        "subtitle": "",
        "title": "Performance Boost Through Eye Control"
    },
    {
        "abstractText": "",
        "description": "The Qt Automotive Suite has now reached the main Qt repositories and is available as open source, just as the rest of Qt. This is a wirlwind tour of the components offered and how they fit into the automotive space - how they work with GENIVI, what problems they address and what parts of the industry that they actually disrupt. We also look at Qt in automotive from an industry trends perspective - what is happening in the upcoming product cycles and why is Qt important.",
        "endTime": "14:05",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 20,
        "presenter": [
            "1088"
        ],
        "room": 5,
        "sessionDay": 1,
        "sessionId": 1170,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "6"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1913:45",
        "startTime": "13:45",
        "subtitle": "",
        "title": "Revolutionizing Automotive with Qt Automotive Suite"
    },
    {
        "abstractText": "",
        "description": "One of the foundation pillars of Qt Quick 2 is its OpenGL-based rendering pipeline. By leveraging the GPU capabilities, we get 60 frames-per-second animated scenes, real time eye candy and special effects, particles, and so on. Moreover, the main programming language is QML, which is extremely popular amongst developers and designers -- it allows them to quickly prototype and build user interfaces. For these reasons, Qt Quick is becoming the de-facto choice on mobile and embedded platforms. However, can we integrate Qt Quick 2 with an existing OpenGL codebase? Would it be possible to reuse old, working, tested OpenGL code and give it a new look and feel by building a Qt Quick interface that uses it? How far can we go with that integration? In this talk, I will show the technologies available in Qt 5.6 that allow deep integration of Qt Quick 2 scenes with custom drawn OpenGL content. We will discuss the possibility of simply providing a Qt Quick overlay for an OpenGL scene. The discussion will then proceed to the creation of custom Qt Quick Items drawn using raw OpenGL commands, which can then be used from QML. Finally, I will illustrate how to manually drive Qt Quick's own rendering if we need to be in complete control of how and when the rendering happens. The audience is expected to have familiarity with basic QtQuick and OpenGL concepts, but no in-depth knowledge of them is required.",
        "endTime": "14:35",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 50,
        "presenter": [
            "1070"
        ],
        "room": 4,
        "sessionDay": 1,
        "sessionId": 1159,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "4",
            "16",
            "19",
            "20"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1913:45",
        "startTime": "13:45",
        "subtitle": "",
        "title": "Integrating OpenGL with Qt Quick 2 applications"
    },
    {
        "abstractText": "",
        "description": "Automated registration desks and info-points are often relegated to a glorified tablet app, with convoluted menus, a lot of (hard) tapping, and with very limited data entry capabilities. Sprout by HP is a Qt powered PC platform, extended with several camera systems, a touch mat and a number of machine vision features that allow creating the next generation kiosk experience - where you don't spend minutes typing in your name or navigating menus, can use equally well digital or paper-based content and even ask for blended reality remote assistance. Real world implementations will be demonstrated that are currently used by automotive, retailers and financial institutions to improve user experience and scaling points of presence. Finally, Qt's role in creating versatile environments as both a UI layer and middleware glue is highlighted.",
        "endTime": "14:05",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 20,
        "presenter": [
            "924"
        ],
        "room": 2,
        "sessionDay": 1,
        "sessionId": 1187,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "14"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1913:45",
        "startTime": "13:45",
        "subtitle": "",
        "title": "Creating the ultimate, blended reality kiosks, info-points and registration desks with Qt and Sprout by HP"
    },
    {
        "abstractText": "",
        "description": "Now that the IoT is a reality, the next step is to leverage this connectivity and transform pieces of information into real problem solvers. One example is the ability to predict failures before they happen; failure prevention allows for reduced maintenance costs, flexibility on intervention time, and fewer emergencies to deal with. Furthermore, it is easy to picture how gathered data, when managed properly, can improve the way devices are used by reducing power consumption, thus becoming more environment-friendly and extending the product life overall. This is made possible by two elements: monitoring how objects are being used (sensors, user actions, failures, etc.) and modeling how and when these objects and components fail (machine learning, AI). This session will focus on how to achieve so-called predictive maintenance, describing various technologies and tools involved, as well as how Qt fits and helps in this space.",
        "endTime": "14:35",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1379"
        ],
        "room": 6,
        "sessionDay": 1,
        "sessionId": 1378,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "3",
            "12",
            "17"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1914:10",
        "startTime": "14:10",
        "subtitle": "",
        "title": "Introducing Predictive Maintenance"
    },
    {
        "abstractText": "",
        "description": "Today manufacturers are struggling to innovate and keep up with Consumer Electronics innovation cycles. The question is why can CE devices run faster cycles than cars? Well, the car is a more complex system that requires more integration, that is one part of the challenge however. The current models of engagement most automotive OEMs have when it comes to HMI can be summarised into two types are the main culprit:\r\n\r\n1. A traditional Tier 1 HW and SW solution, which means that the OEM in effect has to start from scratch every 3 years when delivering their IVI system, each time having to retest functionality like Tuner and Media Player as it’s from a new supplier.\r\n\r\n2. Owning their own HMI platform and framework, which requires massive investment and has a high cost of ownership due to having to build and manage the framework in addition to actually the HMI and UX.\r\n\r\nBoth models make innovation either difficult or too expensive to sustain continuous innovation as we see in the CE market vertical.\r\n\r\nThis talk will introduce a new way to HMI ownership, including a pre-cooked platform that allows the automotive OEMs to build the HMI once (for media, BT, tuner etc) test it, and then innovate into new areas - instead of constantly having to re-integrate the same features onto new HW / SW platforms every new product cycle.",
        "endTime": "14:35",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1321"
        ],
        "room": 5,
        "sessionDay": 1,
        "sessionId": 1320,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "6",
            "17",
            "14"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1914:10",
        "startTime": "14:10",
        "subtitle": "",
        "title": "Taking Control of and Owning Your HMI - Design, Build and Innovate"
    },
    {
        "abstractText": "",
        "description": "CELOS is currently revolutionizing the automation industry. It brings a modern and consistent user interface to DMG MORI's machines providing an intuitive and easy machine operation. By having multiple APPs grouped in categories such as Production or Support each with a single concise scope, CELOS APPs break apart the former monolithic approach. That way the machine operator is guided efficiently and comfortably through a highly complex world, saving up to 30% machine idle time while getting his work done up to twice as fast. This talk will show how HEITEC has assisted its partner DMG MORI in ramping this enormous project up in a relatively short time. Qt has played a key role in this process. It is easy to use and to learn, so that HEITEC's practiced C/C++ programmers had no difficulty getting familiar with Qt and developed themselves into proficient Qt programmers quickly. Qt's clear API and terrific documentation further eases the integration of new colleagues into CELOS. This talk will also cover CELOS' strength and benefits in the area referred to as Industry 4.0. To illustrate, CELOS is horizontally integrated by splitting a job into the creation and information-providing phase (done by the APP JOB MANAGER), the planning phase (JOB SCHEDULER), and it's actual production phase (JOB ASSISTANT). Through it’s connectivity to enterprise resource planning tools, CELOS is integrated vertically into the workflow as well. At the talk's end you will see an exemplary work flow of CELOS showing it's beauty.\"",
        "endTime": "14:35",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1297"
        ],
        "room": 3,
        "sessionDay": 1,
        "sessionId": 1296,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "1",
            "18",
            "5"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1914:10",
        "startTime": "14:10",
        "subtitle": "",
        "title": "CELOS: Revolutionizing the Automation Industry"
    },
    {
        "abstractText": "",
        "description": "The aircraft design process is a complex task, where experts from many different engineering disciplines cooperate on a single objective. Considering each discipline is responsible for only a small part of the entire aircraft - e.g. for the engine, the aerodynamics, or for the loads put to the aircraft structure - the design of a complete aircraft traditionally requires extensive communication between the experts and is therefore a very long and iterative process. In this talk we want to address, how recent software framework and tool developments are changing this situation radically. The large project Digital-X of the German Aerospace Center (DLR) aims at a fully computer-based design of the aircraft and offers a complete virtual flight testing system. This includes an automated analysis and optimization of the entire aircraft. The main idea of the project is a fully automated process, which does not only decrease the time for the aircraft design but also enables the analysis of futuristic non-conventional aircraft appearances. One of our major software developments is the integration framework RCE (Remote Component Environment), which allows coupling many different simulation programs to an automated workflow and steers the data flow between these tools - even across networks to connect different locations of our company. A typical aircraft design workflow includes tools for - design parameterization, - geometry and mesh generation, - the analysis of the aircraft structure, aerodynamics, flight dynamics, - and optimization algorithms. A growing number of these tools are now developed as Open Source Software. Qt plays a constantly increasing role for our software development: One example is DLR’s TiGL library for the generation of aircraft geometries, which is hosted on Github. Its user interface uses Qt to render a 3D visualization of the aircraft geometries. This C++ based software runs on all major desktop systems and additionally on Android, currently with a hybrid Java/C++ implementation. Another Open Source Software is DataFinder, which allows storing and retrieving all the generated simulation data in a convenient and secure way. In this case, PyQt is used for the generation of the user interface. With the automated design and analysis process, DLR is now able to provide a rapid evaluation of novel innovative aircraft design concepts, such as the Blended Wing Body. In an additional presentation in the Qt Application Development &amp; Device Creation session we address some of the Qt specific practices in DLR’s software GTlab for turbomachinery design.",
        "endTime": "14:35",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1078"
        ],
        "room": 2,
        "sessionDay": 1,
        "sessionId": 1164,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "12"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1914:10",
        "startTime": "14:10",
        "subtitle": "",
        "title": "Radical Changes in the Aircraft Design Process Through Software"
    },
    {
        "abstractText": "",
        "description": "Devialet released Phantom in 2015, a revolutionary audio product which set a new standard for high-end connected speakers. In this talk, we will cover how Qt was instrumental in developing this product. We will describe the best practices that allowed a small Software Engineering team to leverage code across multiple platforms from embedded Linux to desktop, iOS and Android while delivering a product on time and budget.",
        "endTime": "15:05",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1102"
        ],
        "room": 6,
        "sessionDay": 1,
        "sessionId": 1180,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1914:40",
        "startTime": "14:40",
        "subtitle": "",
        "title": "Making the Devialet Phantom with Qt"
    },
    {
        "abstractText": "",
        "description": "We tried to make our set­top application a VR ready application, so we have tested 3d headsets to find out how can we integrate our set­top box android application on it or create a hybrid application that can be run on embedded boards and VR headsets.\r\n\r\n3D engines like Unity 3D were the first we studied but we faced many problems:\r\n\r\n \tWe have to use C# which can be very slow in big application due to garbage collector and .NET heavy dlls.\r\n \tIt’s relatively complicated to add controls on top of the UI.\r\n \tGraphical loop, rendering 60fps even if there is no change in the interface.\r\n\r\nWe tested some feature of Qt3D which allow us to use all OpenGL power (with or without graphical loop) and we found many advantages of using Qt such as:\r\n\r\n \tOpenGL power\r\n \tVery easy to add UI elements on top (and multiple of technology’s choices)\r\n \tComplementary modules of Qt for networks and databases...\r\n\r\nTherefore, the main functionality we need to do is the ability to load realistic 3d scenes with materials, textures and lights. We can find all those graphical elements in Fbx files. Fbx file format is the main 3D output of Autodesk 3ds max. The advantage of Fbx format is that it embeds textures, lights and animations.\r\n\r\nIn this presentation, I’ll explain how we can use Qt3D to make realistic OpenGL rendering and use it to create a good virtual reality experience.\r\n\r\nThe first step we made was to develop a Fbx file loader for Qt Quick application using QQuickFramebufferObject. The Fbx file contains a complex 3D scene with all the needed elements to make the scene real (lights, textures, animations...).\r\n\r\nThe loader can handle a big 3D scene and places other objects (other fbx files) in the scene.\r\n\r\nThe second step was to render the scene for right and left eye to use tracked headsets. We used OpenVR to render those images and stream tracking data.\r\n\r\nThe last step was to add some interactions between the user and the scene. We generally use symbol tracking for that to put a virtual mobile application in the scene. we can, for example, change tv content or the whole scene instantly.",
        "endTime": "15:05",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1112"
        ],
        "room": 4,
        "sessionDay": 1,
        "sessionId": 1191,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "15",
            "5",
            "3",
            "14"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1914:40",
        "startTime": "14:40",
        "subtitle": "",
        "title": "Creating Immersive Virtual Reality Experience with Qt3D"
    },
    {
        "abstractText": "",
        "description": "We provide Digitial Instrument Cluster for local automakers in China. The system is based on Linux and QT/QML(Qt 5.5 or later) technology, which need 60fps in 1920x720 resolution. The hardware platform is freescale(NXP) i.Mx6 Dual Lite. We will talk about some tips or experience on how to optimize software as follow, 1.Partial update with Qt for instrument cluster animations. 2.3D Car model rendering performance tradeoff in Qt. 3.QML fast loading policy and key points in instrument cluster development. 4.Integrate mobile navigation into instrument cluster with Qt. 5.A novel method for fast boot Linux and QML will be involved. A full function instrument cluster UI will work within 1.2 seconds(cold boot). The comparative data before and after optimization will be provided based on our hardware platform.",
        "endTime": "15:05",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1111"
        ],
        "room": 3,
        "sessionDay": 1,
        "sessionId": 1190,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "6",
            "14"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1914:40",
        "startTime": "14:40",
        "subtitle": "",
        "title": "Optimize Qt/QML for Digitial Instrument Clusters"
    },
    {
        "abstractText": "",
        "description": "The ever-increasing size and affordability of flat screen panels combined with advances in display and touch technology has opened up a new class of user experience: large-scale, multi-touch, multi-user, natural-feel user interfaces blurring the boundary between physical and digital worlds. One example is Bluescape's visual collaboration Wall: a finger-and-pen touch surface, scalable from a single 30\" display to configurations reaching 400\" of visual space, and using a groundbreaking user interface powered by Qt. Thanks to its rich API and powerful platform integration capabilities, Qt offers a great development framework that scales beyond desktop, embedded and mobile to this new class of user experience. This session will offer insights into the architecture and challenges associated with large-scale systems, as well as Qt usage examples: graphics and input stacks, cross-client support, A/V conferencing, etc.",
        "endTime": "15:05",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1068"
        ],
        "room": 2,
        "sessionDay": 1,
        "sessionId": 1158,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "1",
            "5"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1914:40",
        "startTime": "14:40",
        "subtitle": "",
        "title": "Another Brick In The Wall: developing large-scale user interfaces with Qt"
    },
    {
        "abstractText": "",
        "description": "Stay Tuned!",
        "endTime": "15:35",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1690",
            "1678"
        ],
        "room": 6,
        "sessionDay": 1,
        "sessionId": 1735,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1915:10",
        "startTime": "15:10",
        "subtitle": "",
        "title": "Developing Superior Avionics Technology with Qt"
    },
    {
        "abstractText": "",
        "description": "Qt provides a fantastic set of tools for building apps that can run on multiple platforms, but it's much harder to start using it if you already have pre-existing, native mobile apps for each major platform that you don't want to rewrite.  In this presentation we'll explain how the OneDrive team transitioned its existing, modern applications on iOS, Android, and Windows to using a common, Qt-based cross-platform core with minimal work.  We'll review the reasons you should consider making a similar change, the key technical challenges you'll encounter and how to overcome them, and benefits you can expect as a result of the change.",
        "endTime": "15:35",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1326",
            "1325"
        ],
        "room": 4,
        "sessionDay": 1,
        "sessionId": 1418,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "16"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1915:10",
        "startTime": "15:10",
        "subtitle": "",
        "title": "How to transition your existing, native mobile applications to using a common, Qt-based core"
    },
    {
        "abstractText": "",
        "description": "The challenge for automotive IVI implementations is that most people’s media -- their music, videos,  audiobooks, podcasts and television -- exist in a multitude of forms and originate from many disparate sources. In addition, as the nature of personal transportation is changing and ride-sharing is becoming more common, new requirements for infotainment emerge.\r\n\r\nIn this presentation we outline an architecture for automotive media management that addresses these challenges and we demonstrate a Qt based implementation.",
        "endTime": "15:35",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1222"
        ],
        "room": 3,
        "sessionDay": 1,
        "sessionId": 1569,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "6",
            "17"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1915:10",
        "startTime": "15:10",
        "subtitle": "",
        "title": "Automotive Media Management in Future IVI Systems"
    },
    {
        "abstractText": "",
        "description": "High Fidelity is building an open source platform for virtual reality. QT has played an integral part in the rapid development of this platform.\r\n\r\nThis talk with review how choices for UI and interfaces differ between 3D and 2D (screen) environments and how the company has iterated rapidly to discover what works for users.",
        "endTime": "15:35",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1322"
        ],
        "room": 2,
        "sessionDay": 1,
        "sessionId": 1323,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "1",
            "15",
            "5",
            "14"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1915:10",
        "startTime": "15:10",
        "subtitle": "",
        "title": "Using Qt to Build Interfaces in Virtual Reality"
    },
    {
        "abstractText": "",
        "description": "This session will introduce you to beautiful Qt on Android world. We'll start with setting up the development environment, we'll check the tools, then we'll see how and what to setup on you Qt application to make it a real Android application and finally how to sign your application to prepare it for publishing on Google's Play Market (or any other Android market's out there).",
        "endTime": "16:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 55,
        "presenter": [
            "1086"
        ],
        "room": 6,
        "sessionDay": 1,
        "sessionId": 1169,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "4",
            "16",
            "21"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1916:00",
        "startTime": "16:00",
        "subtitle": "",
        "title": "All about Qt on Android: Say hello to Qt on Android"
    },
    {
        "abstractText": "",
        "description": "This talk is about the success story on how the Dolby Conference Phone (DCP) project accomplished building its own partner ecosystem by developing Conference Service Application Framework (CSAF) around Qt. This enables Dolby to work with multiple conferencing service providers effectively and efficiently.\r\n\r\nBackground about DCP:\r\n\r\nDolby designed the Dolby Conference Phone (DCP) to deliver the Dolby Voice experience, not as just another conference phone. It is an integral component of the Dolby Voice solution, offering stunning audio quality and easy meeting join and management, features that promote productive conferencing. The DCP is a dual mode device – an endpoint for Dolby Voice enabled services and a SIP phone for IP telephony environments. Dolby Voice enabled conferencing service on DCP is provided by partner Conferencing Service Providers (CSPs) like BT, PGI, etc.\r\n\r\nWhy CSAF, what it does?\r\n\r\nThe project had challenges working with multiple CSP partners to integrate their services on DCP software. Traditional approaches needs bigger team and longer release cycles. Any changes, improvements, new features that partner requires, Dolby will have to spend resources to work on, and they have to wait for 3-6 months release cycle for the feature to be ready. Their customers will have to wait even longer. To solve this problem we build CSAF on the DCP to expose core services and component libraries in a framework which enabled our partners to develop conferencing apps using QML. We went extra miles by serving QML/JS conferencing apps over network from HTTP application servers. Cloud deployment model provides rapid development, quick release cycles and modern software management experience.\r\n\r\nQt everywhere!\r\n\r\nCSAF is powered by Qt 4.8. The CSAF exposes QML/JS APIs using QML plugins for UI component library, core services library and network connectivity library. The CSAF app manager uses QML engine as its core with some customizations to securely download the app. SDK for CSAF is built upon Qt creator and we use QDoc to generate complete documentation for APIs and SDK. We also use Qt Quick Test for writing auto tests to validate the framework. CSAF network connectivity APIs are based on QML XMLHttprequest and QWebSockets. Basically we use Qt almost everywhere.\r\n\r\nIn Nutshell: We would like to demonstrate how to pull together the Qt powered application development framework which loads QML apps from cloud and build SDK using Qt tools to complete the offering. Of course, all of this will be backed by a live demo!",
        "endTime": "16:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1110"
        ],
        "room": 4,
        "sessionDay": 1,
        "sessionId": 1189,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "3"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1916:00",
        "startTime": "16:00",
        "subtitle": "",
        "title": "Qt Powered Application Development Framework for the Dolby Conference Phone"
    },
    {
        "abstractText": "",
        "description": "Qt is the leading UI toolkit used by the Automotive industry. This session will talk about the status of Qt in the automotive industry and what we are planning for the future.",
        "endTime": "16:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1468"
        ],
        "room": 3,
        "sessionDay": 1,
        "sessionId": 1469,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "9",
            "6",
            "8",
            "11"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1916:00",
        "startTime": "16:00",
        "subtitle": "",
        "title": "The future of Qt in Automotive and the Automotive Suite"
    },
    {
        "abstractText": "",
        "description": "Qt is a constantly evolving API that has embraced many of the new C++ concepts introduced in C++11 and C++14, but the core QObject class still has some surprising limitations. If you want to use Qt's tried and true signal/slot mechanism, you must derive your classes from QObject, but there are a few subtle snags that you'll have to avoid, including: classes cannot have multiple QObjects in their ancestry, you cannot use virtual inheritance with QObject-based classes, and the Q_OBJECT macro cannot be used in templated classes.\r\n\r\nThe bad news is that these limitations can trip up modern C++ developers who want to use advanced techniques like templates and multiple inheritance. The good news is that Qt is evolving quickly to suit modern needs, and that there are workarounds that can be used today. This talk will focus on techniques that can work around QObject’s current limitations while Qt is still evolving. We will discuss different patterns that programmers can use to write QObject classes that use advanced templating, while still maintaining the myriad of conveniences provided by the QObject system. We will cover how Qt 5’s new connection syntax can solve some modern problems, and present more intricate solutions for the problems left standing. We’ll also go over some tips and tricks using pure virtual functions that can get around QObject’s multiple inheritance issues, while still steering clear of the “dreaded diamond” problem. Finally, we will cover recent discussions on the Qt development mailing list about how Qt contributors can help evolve Qt to better work with templates out-of-the-box, while noting a few key complications that must be solved.",
        "endTime": "16:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1381"
        ],
        "room": 2,
        "sessionDay": 1,
        "sessionId": 1382,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "16"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1916:00",
        "startTime": "16:00",
        "subtitle": "",
        "title": "Shoehorning QObjects into Modern C++"
    },
    {
        "abstractText": "",
        "description": "Hybrid apps traditionally meant bloated web UIs which linked to native code that contained the business logic or heavy calculations. No more. React.js is a JavaScript UI library powering Facebook and Instagram. ReaQt Native is a Qt bridge to this fast-growing JS library that exposes QtQuick and scene-graph performance to React.js (like React Native does for Android and iOS). This way we can have 60fps pixel-perfect web UIs, while avoiding the bloat and sluggishness of WebViews in embedded and resource constrained hardware. While QML has an elegant syntax, the advantage of ReaQt is the general compatibility with the React.js ecosystem. This way not only can the same technology be used on all of web, desktop, mobile and embedded worlds, but web developers and designers traditionally not using Qt can also help building the next generation of performant applications on Qt-supported embedded hardware.",
        "endTime": "16:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "924"
        ],
        "room": 5,
        "sessionDay": 1,
        "sessionId": 1185,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "16",
            "23"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1916:30",
        "startTime": "16:30",
        "subtitle": "",
        "title": "ReaQt Native - building performant web UIs with Qt"
    },
    {
        "abstractText": "",
        "description": "Tableau is one of the foremost data visualization companies and one of the largest Qt projects with over 3 million lines of code committed to the codebase. Operating at this scale requires sociotechnical processes to manage and facilitate developer productivity.  This talk will outline what Tableau has done to maintain quality and feature velocity at the enterprise-level. The target audience is development management.",
        "endTime": "16:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1548"
        ],
        "room": 4,
        "sessionDay": 1,
        "sessionId": 1550,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "22",
            "17"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1916:30",
        "startTime": "16:30",
        "subtitle": "",
        "title": "Operating at Scale with Qt at Tableau"
    },
    {
        "abstractText": "",
        "description": "Our aim is to bring new experiences to automotive customers. Having the ability to rapidly develop and iterate user interaction designs and experiences really provides a competitive advantage. Although the consumer electronics world currently arguably leads and drives the user interface experience, we will explain how the auto industry is quickly catching up to this pace of development. We will also provide insight into how rapid development is enabling the industry to validate designs with ‘real users’ in a real vehicle environment, replacing the need for surveys and clinics, and the benefits of using User Centric Design and a native cross platform application framework like Qt.",
        "endTime": "16:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1577"
        ],
        "room": 3,
        "sessionDay": 1,
        "sessionId": 1578,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "6",
            "17"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1916:30",
        "startTime": "16:30",
        "subtitle": "",
        "title": "Bringing New Experiences to Automotive Consumers"
    },
    {
        "abstractText": "",
        "description": "Medical device manufacturers have two choices when it comes to selecting an operating system for their devices: open source or commercial. The perception with open source is that it a free option but when the total cost of ownership of an operating system is closely examined, a very different picture is painted.\r\n\r\nThe total cost of ownership for a project consists of many factors that may not be immediately apparent.  A simple decision based on a limited analysis of the cost of obtaining and licensing the source code is insufficient, especially when considering large cost items such as development, maintenance, certification, and the overall software team size and dynamic.\r\n\r\nSteven Dean, global healthcare segment manager at QNX Software Systems, will examine the operating system choice for medical device manufacturers and explain how the inherent benefits of faster time to market, easier pre-market approval, and lower total cost of ownership can make a commercial OS a much more attractive option than a “free” OS option.",
        "endTime": "16:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1562"
        ],
        "room": 2,
        "sessionDay": 1,
        "sessionId": 1561,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "3",
            "13",
            "17"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1916:30",
        "startTime": "16:30",
        "subtitle": "",
        "title": "Operating systems for Operating Rooms"
    },
    {
        "abstractText": "",
        "description": "\"What if this thing was magic?\" Designing for the internet of things means blessing everyday objects, places, even people with extraordinary abilities—requiring designers, too, to break with the ordinary. Designing for this new medium is less a challenge of technology than imagination. Sharing a rich set of examples, designer and author Josh Clark explores the new experiences that are possible when ANYTHING can be an interface. The digital manipulation of physical objects (and vice versa) effectively turns all of us into wizards. Sling content between devices, bring objects to life from a distance, weave \"spells\" by combining speech and gesture. But magic doesn't have to be otherworldly; the UX of connected devices should build on the natural physical interactions we have everyday with the world around us. The new UX must bend technology to the way we live our lives, not the reverse.",
        "endTime": "17:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 50,
        "presenter": [
            "1119"
        ],
        "room": 4,
        "sessionDay": 1,
        "sessionId": 1364,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "2"
        ],
        "sessionType": "",
        "sortKey": "2016-10-1917:05",
        "startTime": "17:05",
        "subtitle": "",
        "title": "Magical UX and the Internet of Things"
    },
    {
        "abstractText": "",
        "description": "Lars Knoll, the CTO of The Qt Company and the Chief Maintainer of the Qt Project, will provide a deep dive in the future of Qt technology. What does this mean for example in the upcoming Qt 5.8 release? What does the future hold for Qt technology? In his presentation, Lars will focus on the technical intricacies of where Qt is heading next, as well as explain the vision and foundation of the Qt technology. Lars will also highlight what Qt R&amp;D is focusing on and what to expect in future releases.",
        "endTime": "09:50",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 50,
        "presenter": [
            "935"
        ],
        "room": 4,
        "sessionDay": 2,
        "sessionId": 1703,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "2"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2009:00",
        "startTime": "09:00",
        "subtitle": "",
        "title": "The future is written with Qt"
    },
    {
        "abstractText": "",
        "description": "The use of embedded application processors is exploding as they become the basis of design in markets as diverse as automotive, wearables and industrial IoT. These varied usage models require application processors with a flexible architecture that enable different performance and power profiles within the same system on chip (SoC.) Rob Cosaro has been one of the industry’s leading system architects in designing processors to meet the needs of fast evolving markets by implementing different cores within the same SoC; to create heterogeneous multicore processors. In this presentation Rob will highlight not only the and what &amp; why, but how designers can utilize these parts to create products that meet and scale with fast evolving market needs.",
        "endTime": "10:05",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 15,
        "presenter": [
            "1682"
        ],
        "room": 4,
        "sessionDay": 2,
        "sessionId": 1685,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "2"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2009:50",
        "startTime": "09:50",
        "subtitle": "",
        "title": "Heterogeneous Multicore Processing – What/Why & How"
    },
    {
        "abstractText": "",
        "description": "Bringing the Automotive In-Vehicle Infotainment (IVI) user experience \"kicking and screaming\" into today's fast paced Consumer Electronics-led world.",
        "endTime": "10:15",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 10,
        "presenter": [
            "1577"
        ],
        "room": 4,
        "sessionDay": 2,
        "sessionId": 1579,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "2"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2010:05",
        "startTime": "10:05",
        "subtitle": "",
        "title": "Driving the Consumer Electronics World"
    },
    {
        "abstractText": "",
        "description": "The Qt framework is over 25 years old, and in that time many different technologies have been developed to create graphical user interfaces. This talk aims to lay out what is current landscape of available GUI APIs, and give a better impression of which should be should be used and when, as well as which should be avoided and possible migration paths for existing code. The APIs that we will dive include: QWidgets QPainter QGraphicsView Qt Quick 1 Qt Quick 2 Qt Quick Controls 1 and 2 QWindow OpenGL, Vulkan, Direct3D For each API we will discuss what the API consists of, what features it offers, and what problem it was created to solve. In addition I can give examples of where each API makes sense to be used, as well as some reasons why it can be a bad idea to pick a particular API. The objective is to break the curse of choice that comes with such a flexible framework as Qt and give you a better idea of how to proceed making the best GUI for your application or device.",
        "endTime": "11:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 55,
        "presenter": [
            "1035"
        ],
        "room": 6,
        "sessionDay": 2,
        "sessionId": 1168,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "21",
            "8",
            "14"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2011:00",
        "startTime": "11:00",
        "subtitle": "",
        "title": "The Curse of Choice: An Overview of GUI technologies in Qt"
    },
    {
        "abstractText": "",
        "description": "Boot time is an important characteristic for some systems, such as those which must immediately provide a functioning user interface to its users when powered on. Commonly this capability is achieved using a minimal operating system. However, we will discuss how a full-featured Linux-based Qt-powered device can be optimized to reduce boot time by an order of magnitude. The first half of this presentation will uncover the application and Qt level optimizations and the second half of the session will cover the boot loader/kernal strategies with Qt. We will begin to analyze some of the important hardware attributes that influence a system's boot time.\r\n\r\nA Toradex System-on-Module (SoM) will serve as an example platform requiring exploitation to shed precious milliseconds from boot-up. We will take a look at the boot sequence, digging into the boot ROM, U-boot bootloader, Linux kernel &amp; Qt application. Boot time optimization strategies will be shared for each of these links in the boot chain ultimately allowing the typical boot time for a general purpose embedded Linux system to be reduced from 10-20 seconds to 1-2 seconds for a specialized application.",
        "endTime": "11:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 55,
        "presenter": [
            "1098",
            "1108"
        ],
        "room": 5,
        "sessionDay": 2,
        "sessionId": 1188,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "9"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2011:00",
        "startTime": "11:00",
        "subtitle": "",
        "title": "Fast-Booting Qt Applications on Embedded Linux"
    },
    {
        "abstractText": "",
        "description": "In the Qt organization, we have a strong focus on where we want to be, not just now, but also a few years down the line. But the development needs to go into such solutions a year or two from now, must start today. As such, Qt Lite is the beginning of the future of Qt. In this talk, I will highlight some of the reasons we chose to focus on Qt Lite, cover what Qt Lite is and is supposed to be, and give some examples of business cases that Qt Lite will enable in the future. Qt Lite is also developed in close collaboration with our partners and customers, aiming at improving Qt as much as possible, and making it the technology of choice also in new products, markets and device types.",
        "endTime": "11:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1037",
            "935"
        ],
        "room": 4,
        "sessionDay": 2,
        "sessionId": 1182,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "11",
            "17"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2011:00",
        "startTime": "11:00",
        "subtitle": "",
        "title": "Where Qt is going - Qt Lite"
    },
    {
        "abstractText": "",
        "description": "GammaRay is a high-level introspection tool for Qt programs that enables you to visualize and manipulate application behavior at runtime. In this talk we will look at a number of real-world debugging and profiling problems and how the capabilities provided by GammaRay help you to analyze and solve those. When creating applications we strive to use higher-level frameworks in order to obtain results quickly and reduce development effort as well as long-term maintenance cost. This however provides a few challenges during debugging and profiling. With conventional instruction-level tools we need to have a reasonably deep understanding of the implementation of the frameworks, libraries and components we use, to interpret the results correctly. Tools with an understanding of the building blocks we use mitigate this problem. GammaRay is such a tool for Qt. After a brief introduction on how to use GammaRay for local and remote targets, we will look at a number of debugging and profiling examples covering a wide range of Qt features such as signals/slots, Qt Quick, widgets, state machines, model/view or Qt3D, and see how GammaRay can help in addressing these. All examples are based on real-world problems KDAB engineers encountered in their daily work, and aim at giving you an idea on how GammaRay can help with problems you might encounter in your own Qt application. If you have ever spent hours or even days wondering why one of your signal/slot connections seemed to have a mind of its own, why a Qt Quick button was accepting clicks only when it felt like it, or why your QML HMI was rendering a bit slowly on your embedded target device, this talk is for you.",
        "endTime": "11:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 55,
        "presenter": [
            "937"
        ],
        "room": 3,
        "sessionDay": 2,
        "sessionId": 1181,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2011:00",
        "startTime": "11:00",
        "subtitle": "",
        "title": "GammaRay - Taking a deep look into your Qt application"
    },
    {
        "abstractText": "",
        "description": "IPv6 is the evolution of the Internet Protocol and was created in the late 1990s when it was clear that the then-current version (IPv4) would run out of available addresses soon. Soon after, software was converted to handle IPv6 and the all service providers began offering IPv6 connectivity. Right? Not really. While a lot of applications did add support for IPv6, that conversion was by far not widespread enough. That created a chicken-and-the-egg problem with the service providers not deploying IPv6: no applications supported it, so connectivity wasn't necessary, so developers didn't add support in their applications, ... The Internet of Things, however, will change that scenario. With a predicted 40 billion devices connected in a couple of years' time, IPv4 will clearly not be enough. As a point of fact, all but one of the Regional Internet Registries, the organisations that administer the IP address space, have run out of blocks they can delegate to new clients. Moreover, new mesh-connectivity technology is being designed, first and foremost, for IPv6, especially 6LoWPAN, Thread, and 6lo-over-Bluetooth LE. That means application support is required now, more than ever. New protocols should be designed, from the drawing board, to take advantage of IPv6. In specific for IoT, since most of the domain is green field right now, designing for IPv6 is possible and should be encouraged. This session will go over the basics of IPv6, how it differs from IPv4 and what application developers should be aware of. It will go over the basic C socket API and then move on to how IPv6 is accessible in the Qt API, thus explaining how to write software capable of both IPv4 and v6, seamlessly. It will then discuss how application protocols can benefit of the expanded address space, multicasting abilities, header compression in mesh networks and other technology not available in IPv4. The presenter is a system architect for Internet of Things in Intel's Open Source Technology Center. In addition to being QtCore and QtDBus's maintainer, he's a regular contributor to QtNetwork and recently added classes like QNetworkDatagram to that module.",
        "endTime": "11:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 55,
        "presenter": [
            "1106"
        ],
        "room": 2,
        "sessionDay": 2,
        "sessionId": 1184,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "4",
            "16",
            "21"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2011:00",
        "startTime": "11:00",
        "subtitle": "",
        "title": "IPv6 for Beginners"
    },
    {
        "abstractText": "",
        "description": "This breakout session is meant for developers to give insights into the workings of the configuration system that is at the heart of Qt Lite.",
        "endTime": "11:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "935"
        ],
        "room": 1,
        "sessionDay": 2,
        "sessionId": 1704,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "11"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2011:30",
        "startTime": "11:30",
        "subtitle": "",
        "title": "Qt Lite’s configuration system explained"
    },
    {
        "abstractText": "",
        "description": "As announced earlier this year, the Qt graphics stack - and first and foremost, Qt Quick - is undergoing the most significant changes since its introduction in Qt 5.0. The aim of the modularization process is to remove the strong OpenGL dependency, paving the way for other graphics APIs in the future, and to strengthen support for environments where accelerated graphics is not feasible. The previously standalone Qt Quick 2D Renderer is going to become a core part of Qt Quick, with the license changing to LGPLv3 to be in line with Qt's main modules. This makes the 2D Renderer available out of the box on every platform. In addition to a number of internal changes and enhancements, the introduction of partial updates will be visible to every user of this backend since the expensive full-screen updates plaguing earlier releases are now eliminated. To prove that the changed Qt Quick Scenegraph interfaces are suitable to handle graphics APIs different from OpenGL, an additional, proof-of-concept backend using Direct3D 12 is being developed in parallel with the rest of the changes. This also provides the foundations for potential future support for APIs like Vulkan or Metal. OpenGL is not left behind either. Modern techniques based on AZDO and OpenGL ES 3.2, potential vector graphics enhancements, as well as optimizations benefitting embedded and mobile environments, like pre-compiled shaders or compressed textures, are being researched for future Qt releases. While OpenGL remains the default, number one choice, and many Qt Quick applications are expected to be able to run on a different backend without changes, there are cases, typically involving custom QQuickItems or shader effects, that will need attention and potentially a few changes from the applications. The first set of the Qt Quick improvements are expected to get integrated into Qt 5.8, due H2/2016. It is now therefore time to take a look at what these changes mean in practice and which direction Qt Quick is heading in the future.",
        "endTime": "12:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1033",
            "1035"
        ],
        "room": 6,
        "sessionDay": 2,
        "sessionId": 1151,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "20",
            "8"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2012:00",
        "startTime": "12:00",
        "subtitle": "",
        "title": "Qt Quick Scene Graph Advancements in Qt 5.8 and Beyond"
    },
    {
        "abstractText": "",
        "description": "Many Qt users enjoyed the benefits of the Qt Visual Studio AddIn provided for various Visual Studio versions, starting with Visual Studio 2010. Unfortunately, Microsoft decided to deprecate the API to implement an AddIn a while ago and completely removed this functionality with Visual Studio 2015. This caused a significant break in developer experience for those users who have been relying on the Qt Visual Studio Addin. Hence, the Qt Company has been working on the Qt Visual Studio Tools, which will replace the previous Visual Studio AddIn. As the Qt Visual Studio Tools have been recently released (Note to committee: According to current roadmap), the Qt World Summit is the perfect moment to introduce it to the audience. The speaker will highlight the workflow of installing and getting started with the Qt Visual Studio Tools. Following to this, differences to the previous Visual Studio AddIn will be discussed as well as new features presented. In addition to this, a couple of features for developers on the Universal Windows platform have been introduced, helping to integrate Qt deeper into the platform and enhancing the developer experience on this platform. Lastly, the presentation will talk about future items on the Roadmap for the Qt Visual Studio Tools as well as open a discussion about missing features for the audience.",
        "endTime": "12:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "632"
        ],
        "room": 5,
        "sessionDay": 2,
        "sessionId": 1177,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "21",
            "24",
            "8",
            "11"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2012:00",
        "startTime": "12:00",
        "subtitle": "",
        "title": "Introducing Qt Visual Studio Tools"
    },
    {
        "abstractText": "",
        "description": "Stay tuned",
        "endTime": "12:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1533"
        ],
        "room": 2,
        "sessionDay": 2,
        "sessionId": 1479,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "11",
            "17",
            "7"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2012:00",
        "startTime": "12:00",
        "subtitle": "",
        "title": "How to select a service partner"
    },
    {
        "abstractText": "",
        "description": "Developing applications with QML can be a very pleasant experience: Quick development cycles, intuitive syntax and integrated tooling that get you up and running. But when your team's application grows with numerous QML components, new imports and countless properties, obstacles may appear. Often, the first symptom is slower application start-up or increased memory consumption. Thus, scalability is a key focus for us when developing the QML engine. In this presentation we are going to begin with a brief review of some of significant milestones from the past months. Then, we will discuss how your team can benefit from these improvements. For example, the new cache architecture that supercedes the Qt Quick compiler, reducing the overall memory consumption through on-demand paging and caching of generated code across application restarts. Perhaps this is your chance to provide feedback (both good and bad) and give input for our future plans.",
        "endTime": "13:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1084"
        ],
        "room": 6,
        "sessionDay": 2,
        "sessionId": 1167,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "8"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2013:30",
        "startTime": "13:30",
        "subtitle": "",
        "title": "The QML Engine: Future Plans and Paths"
    },
    {
        "abstractText": "",
        "description": "Physics Based Rendering (PBR) is the latest and greatest trend in real-time rendering yielding much more visually believable images than the traditional Phong or ad-hoc lighting models. The underlying concept is that the shaders should use physical principles in the encoded models - chief of which are conservation of energy and the Fresnel effect. PBR is used in many AAA game titles but here we will show how to make use of it with Qt 3D as it is widely applicable to many other types of 3D content such as for use within engineering and visualization. In this talk we will cover how to go take your raw 3D meshes, look at how to prepare textures suitable for use with a PBR-based workflow and how to feed these into a Qt 3D application. Along the way, we will explain how Physics Based Rendering works and how its formulation helps convince the brain of its realism without destroying performance. We will also take a look at some techniques that are often used in conjunction with PBR such as ambient occlusion and parallax mapping. Time permitting we will look briefly at how to add some post-processing effects to your Qt 3D renderer setup. Physics Based Rendering is a family of techniques for simulating how light interacts with surfaces. It can be applied in both offline renderers such as path tracers used in the production of television and film VFX, and more importantly for us, in real time rendering systems such as Qt 3D. There are two main groups of PBR techniques that fall under the Metal-Roughness and Specular-Glossiness workflows. This talk will concentrate on the Metal-Roughness workflow. We will show all the tooling required to take simple 3D meshes, uv-unwrap and export them for use in specialized texturing tools that can then be used to generate the images needed to feed into PBR GLSL shaders. In addition to the material textures, we will also show how to process HDR environment maps to allow high quality specular reflections to be calculated in real time. The talk will explain how all of these assets work together to produce convincing results. We will also provide tips on reducing the overall memory usage by using modern GPU facilities for managing textures.",
        "endTime": "14:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 55,
        "presenter": [
            "1090"
        ],
        "room": 5,
        "sessionDay": 2,
        "sessionId": 1171,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "15",
            "16",
            "8",
            "11",
            "7"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2013:30",
        "startTime": "13:30",
        "subtitle": "",
        "title": "Qt 3D and Physics Based Rendering"
    },
    {
        "abstractText": "",
        "description": "Qt Creator is a cross-platform C++ integrated development environment (IDE), ideally suited for Qt development. This session will provide a introduction to using the IDE, demo some of its highlights and provide some tips along the way.",
        "endTime": "14:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 55,
        "presenter": [
            "1092"
        ],
        "room": 4,
        "sessionDay": 2,
        "sessionId": 1179,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "21",
            "24",
            "10"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2013:30",
        "startTime": "13:30",
        "subtitle": "",
        "title": "Introduction to Qt Creator"
    },
    {
        "abstractText": "",
        "description": "A walkthrough of the new Handler classes which are planned as a Tech Preview release in Qt 5.8, and the use cases for them: taps, pinches, drags, flicks, and custom touchpoint handling. In previous versions of QtQuick, we had a few Items specialized for handling pointing device events, such as MouseArea, Flickable, PinchArea, and MultiPointTouchArea. Some of them are limited to handling mouse events, so when you use a touchscreen, they rely on receiving synthesized mouse events. This precludes touch interaction with multiple Items, because of the assumption that there is only one mouse - despite the fact that you are using a multi-touch screen. At the 2015 Qt Contributors' Summit, we discussed a potential solution to the problem, from which the present implementation has evolved. The solution is to have one type of event (a synthetic wrapper in Qt 5, and a common base class in Qt 6) for all pointing-device events, and a new larger set of lightweight Handler objects, focused purely on handling events. They can be device-agnostic, or can filter events from specific kinds of devices. They are not Items themselves, but pointer-handling aspects of Items. This talk will be an exploration of these Handlers and their use cases: how to achieve fluid, multiple-touch, multiple-user UIs in Qt Quick.",
        "endTime": "13:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1072"
        ],
        "room": 3,
        "sessionDay": 2,
        "sessionId": 1160,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "9",
            "20",
            "8",
            "11",
            "14"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2013:30",
        "startTime": "13:30",
        "subtitle": "",
        "title": "Pointer Events and Handlers in Qt Quick"
    },
    {
        "abstractText": "",
        "description": "This talk provides an introduction to user experience design, specifically focusing on issues that software engineers encounter. While engineers tend to focus on the implementation details of getting pixels on the screen, less consideration is often given to what pixels go where, and who besides the engineer will be interacting with them. In this session we will present an overview of the UX process, highlighting several best practices. You will come away from the session with a better understanding of the thought process needed to create a high-quality user experience and a set of actionable guidelines to keep in mind during implementation.",
        "endTime": "13:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1074"
        ],
        "room": 2,
        "sessionDay": 2,
        "sessionId": 1161,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "7",
            "14"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2013:30",
        "startTime": "13:30",
        "subtitle": "",
        "title": "User Experience Design for Software Engineers"
    },
    {
        "abstractText": "",
        "description": "QtWebEngine lets you access the features and raw power of a leading web browser platform (Chromium) through a convenient Qt API. First released with Qt 5.4, Qt WebEngine features both a Qt Widget and a Qt Quick integration to render regions of dynamic web content. With Qt 5.7 and the upcoming 5.8, Qt WebEngine offers new features and better integration. In this talk, we will give an overview of some of the newest features in Qt WebEngine and the possibilities they enable.",
        "endTime": "14:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1094"
        ],
        "room": 6,
        "sessionDay": 2,
        "sessionId": 1173,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "11"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2014:00",
        "startTime": "14:00",
        "subtitle": "",
        "title": "New Possibilities with Qt WebEngine"
    },
    {
        "abstractText": "",
        "description": "To test a Qt or QML application there are many different test types, such as unit tests, functional tests, non-functional tests, system tests, integration tests, etc., which can and should be done. Each of these test types focus on different aspects of the testing and are complementary to each other. Several of the mentioned test types can be partially of fully automated. In this talk you will learn about all challenges of automating the functional HMI testing and visual verifications of system tests of Qt and QML user interfaces on embedded, desktop and mobile platforms. The talk will explain differences, overlaps and specific requirements and challenges of these two test types. The presenter will concluded the session with a live demonstration.",
        "endTime": "14:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1355"
        ],
        "room": 2,
        "sessionDay": 2,
        "sessionId": 1152,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "9",
            "20"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2014:00",
        "startTime": "14:00",
        "subtitle": "",
        "title": "Automating HMI- and System-Tests for Qt and QML Frontends"
    },
    {
        "abstractText": "",
        "description": "Since version 5.2, Qt has been available on iOS. In this talk, we go through the process of building a simple QML application, run in the simulator, and deploy to a device. We first look at the creator project and settings that are specific to iOS such as targeted devices, SDKs, required capabilities, etc. We also look at Qt Creator tooling related to simulator and devices deployment. We will mention where Xcode still outperforms Creator, in particular when it comes to debugging and performance analysis. After looking at a simple QML app, we investigate the coverage Qt relative to the native capabilities. In particular we'll focus on text editing, keyboard customising, keyboard avoidance, accessing the sensors (location, orientation, camera), support of different screen sizes and DPI, etc. Then we look at how integrating with the native toolkits for accessing feature not covered by the QML layer. Using Objective C++ and Qt's iOS specific integration layer, we show how to access features from UIKit. Finally we will look at performance pitfalls that are common on iOS and how to detect and mitigate them using a variety of tools.",
        "endTime": "15:35",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 55,
        "presenter": [
            "1082"
        ],
        "room": 5,
        "sessionDay": 2,
        "sessionId": 1166,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "21",
            "10"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2014:40",
        "startTime": "14:40",
        "subtitle": "",
        "title": "Qt for iOS A to Z"
    },
    {
        "abstractText": "",
        "description": "Since the initial version of Qt supporting Windows Runtime a lot has happened, both on the platform side as well as in Qt. Starting with an overview of the roadmap, new features, internals and stability changes will be discussed, applying to Windows 10, Windows 10 Mobile and Windows 10 IoT Core. In the second part different techniques to publish an application in the Windows Store will be presented. For instance, to increase the amount of applications in the store Microsoft provided means to push classic desktop applications. However, there are several pitfalls with this approach, which will be highlighted. While Qt provides a huge amount of features for all supported platforms, there are still items provided by the underlying platform a developer might want to integrate. There are multiple approaches to achieve integration of those features into a Qt application and some might not be available to C++ by default. In the last section, the speaker will present a couple of methods, highlighting benefits and potential downsides of each.",
        "endTime": "15:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 55,
        "presenter": [
            "632"
        ],
        "room": 6,
        "sessionDay": 2,
        "sessionId": 1175,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "12",
            "9",
            "8"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2015:00",
        "startTime": "15:00",
        "subtitle": "",
        "title": "Integrating Universal Windows Platform to Qt"
    },
    {
        "abstractText": "",
        "description": "At the heart of Qt is the QObject and the technologies that drive this. As Qt developers we love to use signals and slots, the events, the introspection and all those other features. But how do those actually work? Surprisingly few Qt developers truly understand how the QObject systems work. And by not understanding, they fail to grasp the full potential of what this can help you with. In this talk, we will dive very deep into the belly of the beast and discuss how it actually works. You will see what moc does, how it's related to QObject and why it's necessary. You will learn all there is to learn about what QObject does for your objects. We will also look at the Qt event loop and see how this is related to QObject and the Qt signals. This is necessary to understand what happens to your Qt signals. And finally, we will have a discussion about how this should modify the architecture of your code, how you should modify the way you think code to best make use of Qt. The full use of Qt allows you to code self contained components - getting away from the dreaded spaghetti code. The aim of this talk is to give the developer the necessary background knowledge to make the right decisions about Qt based designs in the code.",
        "endTime": "15:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 55,
        "presenter": [
            "940"
        ],
        "room": 1,
        "sessionDay": 2,
        "sessionId": 1162,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "10"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2015:00",
        "startTime": "15:00",
        "subtitle": "",
        "title": "QObject Deep Dive"
    },
    {
        "abstractText": "",
        "description": "Mobile Qt World Summit 2016 Conference App is developed by ekke using new Qt Quick Controls 2. This session will give you some insights:\r\n\r\n- Qt Quick Controls 2\r\n- Customizing Controls\r\n- UX and Navigation\r\n- High DPI Support\r\n- Icons / Image Management\r\n- Databinding\r\n- Caching\r\n- Accessing HTTP REST Services\r\n- Internationalization\r\n- Qt Creator 4 to develop, build and release on Android, iOS and Windows 10\r\n\r\nEkke will talk about his experiences, explain patterns used and give you some tips and tricks. You'll also learn about issues, open questions and workarounds. The Conference app is Open Source at GitHub so you can use it as a starting point to develop your own mobile apps with Qt 5.7+. Ekke will take a look at the source code to go into some details and you can try it out on your own devices running the conference app. If you're coming from Android or iOS development, Ekke will give you hints How To start - if you're coming from BlackBerry Cascades, Ekke will show you, which parts of your sources can be re-used. There's a Q&amp;A part at the end where you can give feedback about the app and discuss.",
        "endTime": "15:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 55,
        "presenter": [
            "1475"
        ],
        "room": 5,
        "sessionDay": 2,
        "sessionId": 1476,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "5",
            "21",
            "8"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2015:00",
        "startTime": "15:00",
        "subtitle": "",
        "title": "Qt World Summit Conference App: Behind The Scenes"
    },
    {
        "abstractText": "",
        "description": "\"Ask me for anything but time,\" said Napoleon. Time is something that all projects and all applications need to deal with: to make application UIs look fluid, there's a time budget for every frame, handling data must be done in a deadline, and so forth. It's also one of the two sources of events in an event-loop-based application (the other being socket/file descriptor notifications), so it's used very often. Qt offers a number of classes for dealing with time, ranging from obtaining the system time and dealing with timezones, to measuring time intervals, calculating deadlines, to scheduling futere events. It's a very powerful API and very extensive, grown over time, which means there are often doubts about how to do things right. In order not to waste time to measure time, it's important to know how to use the right tool for the right job. This session will go over all the classes related to timekeeping offered by Qt. It will explain what each one is meant to be used for and how to use them efficiently. It will spend time talking about the event loop in Qt, the dos and don'ts of timing in a GUI application and how threading can help. It will also give a preview of new API coming in Qt 5.8, which should include compatibility with C++11's std::chrono functionality. The presenter is QtCore and QtDBus's maintainer and is an IoT system architect for the Open Source Technology Center at Intel. He's been working on the internals of QtCore and trying to optimise it to make things as small and as efficient as possible, such as the upcoming \"Short Datetime Optimisation\".",
        "endTime": "15:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 55,
        "presenter": [
            "1106"
        ],
        "room": 4,
        "sessionDay": 2,
        "sessionId": 1186,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "8"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2015:00",
        "startTime": "15:00",
        "subtitle": "",
        "title": "Handling time in a timely manner"
    },
    {
        "abstractText": "",
        "description": "Qt is used in an extremely wide variety of use cases across multiple industries, sometimes also in safety critical systems. When a system, be it a medical device, railway control system, or an automobile, can potentially cause harm to humans, the concept of functional safety helps in assessing the risk and taking the necessary measures to steer the risk to an acceptable level. This presentation introduces the key concepts for functional safety and explains how to use Qt in a system certified for functional safety according to IEC 61508 and ISO 26262. ",
        "endTime": "15:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1063"
        ],
        "room": 2,
        "sessionDay": 2,
        "sessionId": 1147,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "17"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2015:00",
        "startTime": "15:00",
        "subtitle": "",
        "title": "Creating Functional Safety Certified Systems with Qt"
    },
    {
        "abstractText": "",
        "description": "In this presentation Mr. Murali Mandayam will go through solutions for tackling the most common issues in the execution of a large-scale software program. The learning are based on the extensive experience our embedded customers over the years. However, these results are easy to generalize to cover any large-scale software project when creating innovative embedded devices based on Qt. Software projects in reality start earlier than the first lines of code are written. In this presentation, we will look go through our learning starting already from the technology selection and extending all the way to the final maturization of a device software. The biggest decisions contributing to a short time-to-market are done in the early days of the software program. Understanding the final user experience at least on a conceptual level helps any program to decide the requirements for hardware. It is fundamental that the hardware decision is done with software in mind. This may sound naïve but still today, we constantly face projects where cost of a piece of silicon is driving the decision with a mindset “software will be adjusted to work with this”. The right hardware with the right system architecture gives you a solid foundation for fast time-to-market. Other elements of the short time-to-market are in the hands of software units from design to actual implementation with good software practices. In the presentation, we will take a closer look on each of the phases we have recognized in the embedded device creation project and address the solutions for the top issues in each phase. The issues can be solved roughly in two different ways – using the right Qt tools / capabilities or changes in the way of working throughout the organization. We will illustrate with examples how to concretely shorten the time-to-market with the Qt tools available from us and/or our key partners. Furthermore, we will share the best practices from our customer cases in building the most capable software processes for embedded device creation.",
        "endTime": "15:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1738",
            "1533"
        ],
        "room": 2,
        "sessionDay": 2,
        "sessionId": 1155,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "17"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2015:30",
        "startTime": "15:30",
        "subtitle": "",
        "title": "Accelerating Time To Market for Embedded Device, Qt Learnings"
    },
    {
        "abstractText": "",
        "description": "Qt Quick is a UI framework that enables development of user interfaces using a declarative language. It is built on a dedicated scene graph based on OpenGL that fully utilises the GPU. Using primitive building blocks, you can create custom, animated user interfaces with full control over every pixel.\r\n\r\nQt Quick Controls 2 complements Qt Quick by providing higher level templates for common UI elements such as buttons and sliders. The template system was designed for visualising controls with a minimal amount of effort, which leads to excellent performance on any platform. It comes with ready-made styles that fill in the templates. Examples of these styles are Google's Material and Microsoft's Universal designs.\r\n\r\nThis talk will take a look behind the scenes and explain the implementation and how we achieved good performance on low-end devices, as well as how to style an application.",
        "endTime": "16:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1072"
        ],
        "room": 6,
        "sessionDay": 2,
        "sessionId": 1423,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "20",
            "11",
            "14"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2016:00",
        "startTime": "16:00",
        "subtitle": "",
        "title": "Developing user interfaces with Qt Quick Controls 2"
    },
    {
        "abstractText": "",
        "description": "For a product as versatile and customizable as Qt, it is quite common for customers to look for professional help when integrating and implementing their software stack. Whether it is a board level integration of Qt library or user experience design, or application development there is no \"one-size fits all” as every customer’s needs are unique. Getting professional help also gives customers an opportunity to differentiate their product and accelerate their time to market. We have 4 distinguished panelists here to talk about how they can help you (customer) to be successful with Qt. This interactive session will be open for Q&amp;A.\r\n\r\n&nbsp;",
        "endTime": "16:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1533"
        ],
        "room": 1,
        "sessionDay": 2,
        "sessionId": 1532,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "11"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2016:00",
        "startTime": "16:00",
        "subtitle": "",
        "title": "How to Choose a Service Partner"
    },
    {
        "abstractText": "",
        "description": "In this talk we’ll take a look at the current state of Qt on macOS as well as ongoing work and future improvements.\r\n\r\nWe will take a look at how to combine Qt and native API usage from the same code base. This includes a brief Objective C++ introduction and a look at how to use type conversion functions to move data between Qt and native types.\r\n\r\nWe will look at several options for tool bar styling, both for Qt Widgets and QML based applications.\r\n\r\nFinally, we will look at how to work with the native window and view classes to mix Qt application content with visual effects views, HUD windows and popovers.",
        "endTime": "16:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1478"
        ],
        "room": 5,
        "sessionDay": 2,
        "sessionId": 1477,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "11"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2016:00",
        "startTime": "16:00",
        "subtitle": "",
        "title": "Qt on macOS Updates"
    },
    {
        "abstractText": "",
        "description": "The Qt WebEngine module integrates Chromium into Qt. It replaces the now deprecated Qt WebKit module. While the efforts to keep the changes between the two modules' APIs as small as possible were successful in most parts, Qt WebEngine is not a drop in replacement because some API could not simply be ported, and some users are facing difficulties when porting their applications. This is mainly due to the different process architectures: while the Qt WebKit C++ APIs are running the rendering engine in the same process as the application, this is not possible in Qt WebEngine, as Chromium uses a multi-process architecture for improving stability and security. This talk will give an overview of the most common differences that application developers need to adjust to when porting their application from Qt Webkit to Qt WebEngine. It also aims to provide hands-on solutions to these problems and give guidance on how to work around features that Qt WebEngine simply cannot offer in the same way as Qt WebKit. Where time allows, a deeper look into the reasons for some changes will be taken. Last but not least, it will show some of the many features that Qt WebEngine supports that were not available in Qt WebEngine.",
        "endTime": "16:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 55,
        "presenter": [
            "1094"
        ],
        "room": 4,
        "sessionDay": 2,
        "sessionId": 1183,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "11"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2016:00",
        "startTime": "16:00",
        "subtitle": "",
        "title": "Porting from Qt WebKit to Qt WebEngine - a hands-on guide."
    },
    {
        "abstractText": "",
        "description": "State Chart XML (SCXML) is a common format to specify state machines. It has been standardized by the W3C and there are many applications that produce or process it. State charts provide a graphical way of modeling how a system reacts to stimuli. This is done by defining the possible states that the system can be in, and how the system can move from one state to another. State charts offer a very concise representation of business logic, and limit the potential for unexpected behavior. Qt 5.7 comes with a technical preview of Qt SCXML, a module to integrate state charts specified in SCXML into your application, and execute them in accordance to the W3C specification. This way a Qt application can be driven from a state chart, rather than from business logic expressed in C++ or QML. With Qt SCXML, SCXML documents can be compiled into C++, which can then be readily integrated into any Qt application. Alternately, SCXML documents can also be dynamically loaded and interpreted at run time. In both cases, states are exposed via Qt properties, so that QML properties can effortlessly be bound to them. It is thus very easy to attach a Qt Quick UI to an existing, or newly written, state machine. The talk will show the full workflow of creating a state machine in a visual design tool, integrating it into a project with Qt Creator, adding a custom data model, and attaching a user interface to it, using QML and Qt Quick.",
        "endTime": "16:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 55,
        "presenter": [
            "1092"
        ],
        "room": 3,
        "sessionDay": 2,
        "sessionId": 1172,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "11",
            "7"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2016:00",
        "startTime": "16:00",
        "subtitle": "",
        "title": "Qt SCXML: State Machines Made Easier"
    },
    {
        "abstractText": "",
        "description": "The use of embedded application processors is exploding as they become the basis of design in markets as diverse as automotive, wearables and industrial IoT. These varied usage models require application processors with a flexible architecture that enable different performance and power profiles within the same system on chip (SoC.) In this session we will focus on the NXP i.MX7 as an example of an application processor that with both an ARM A and M core that enables radically different product designs and software implementations. The details of the SoC architecture and boards designed around the part for different usage models will be discussed so designers can understand not only what, but how to utilize the i.MX7 for their next product.",
        "endTime": "16:25",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1684",
            "1682"
        ],
        "room": 2,
        "sessionDay": 2,
        "sessionId": 1686,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "12",
            "9",
            "8"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2016:00",
        "startTime": "16:00",
        "subtitle": "",
        "title": "NXP i.MX7 – How to utilize Heterogeneous Multicore Processing in your next design"
    },
    {
        "abstractText": "",
        "description": "Geolocation is a must-have element of any modern application design today. More and more applications are becoming location-aware, and the demand for geographic content, maps and functionality in mission-critical workflows is increasing all the time. Managers are challenged with injecting authoritative, reliable geospatial information into their applications for real-time decision support, while optimizing performance, stability and simplicity for the user. Developers need complete geolocation APIs and SDKs to build apps that can visualize and analyze maps and mapping data, and support the end user in making the most informative decisions in any situation. Outcomes must be productive, in that they are easy and intuitive to develop applications and solutions with. They must be able to build great user experiences, intuitive, easy to use, GUI and non GUI-based apps that are versatile enough to work with geo-enabled Web Services as well as data and maps that reside locally on a device, simultaneously. These are just some of the key elements that today’s app developers need in a developer toolset.\r\n\r\nEsri’s ArcGIS Runtime SDK for Qt is a developer kit that provides all of the crucial tools and APIs for building great location-aware apps. It extends the Qt framework to assist in creating highly functional apps that can have both rich mapping and analytical capabilities, optimized to run on multiple platforms and devices, from Android, Mac and iOS devices to Windows and Linux desktops and embedded systems. This presentation discusses and demonstrates Esri’s rich, geospatial Runtime Qt SDK. Demonstrated capabilities include Mapping and Visualization, as well as Collecting, editing and managing geographic business data, online or offline.",
        "endTime": "16:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1096"
        ],
        "room": 6,
        "sessionDay": 2,
        "sessionId": 1174,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2016:30",
        "startTime": "16:30",
        "subtitle": "",
        "title": "Building Location Analytics and Mapping into Your Mission-Critical Solutions."
    },
    {
        "abstractText": "",
        "description": "Stay Tuned",
        "endTime": "17:00",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 30,
        "presenter": [
            "1473"
        ],
        "room": 1,
        "sessionDay": 2,
        "sessionId": 1471,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "8"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2016:30",
        "startTime": "16:30",
        "subtitle": "",
        "title": "Let's Talk Law/policy for Devices from a Software Perspective"
    },
    {
        "abstractText": "",
        "description": "One of the most important aspects of a streamlined software development pipeline is the build system. As a tool that developers use throughout the day, every day, a good build system should be lightning fast, easy to use, and produce instantaneous and correct incremental builds. Build systems that are slow, hard to maintain, or incorrectly specify dependencies (leading to broken or malfunctioning builds) significantly impact your team’s workflow and waste countless hours of time.    Qbs aims to be the perfect high level cross platform build system -- and hopeful replacement for qmake within Qt. It started as a research project at Nokia in 2010 and has been ongoing since. It aims to support any toolkit, any language, and any OS, with excellent support for cross compilation, IDE integration, device deployment &amp; packaging, speed, flexibility, expressiveness, and ease of use.    This talk provides an introduction to Qbs and how it compares to other build systems like CMake and qmake. It will cover the general design of Qbs, illustrate the power of its dependency management system, and show off some of its unique features like ABI-based linking optimization, building for multiple platforms in parallel, and library-based design. It will also show off some of the powerful new features coming in future versions, such as first-class support for code-signing on all platforms, and integration with popular IDEs like Xcode and Visual Studio.",
        "endTime": "16:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1481"
        ],
        "room": 5,
        "sessionDay": 2,
        "sessionId": 1581,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "21",
            "11"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2016:30",
        "startTime": "16:30",
        "subtitle": "",
        "title": "Qbs - the Next Generation of Build Automation"
    },
    {
        "abstractText": "",
        "description": "This session shows how to develop applications for multiple screen sizes, screen resolutions and form factors like phones, tablets and desktop PCs with Qt. We show how you can use the same code base, while having native-looking UIs &amp; UX across platforms. This involves tips for responsive design with Qt, how to best use the new Qt Quick Controls, and a comparison when to use Qt Quick and in which cases C++ is the better choice. We also explain how you can simulate multiple screen resolutions and platforms including iOS &amp; Android and their native UI from a single Desktop application. In the second part of this session, we will highlight how you can leverage the full app lifecycle with Qt: from design to development, testing, deployment to publishing. And how you can efficiently perform post-publishing tasks like analytics &amp; ongoing app improvements in the Qt ecosytem. This presentation gives you a non-technical overview of the possibilities with Qt for multi-screen and multi-platform development and shows best practices for an efficient app lifecycle with Qt. For an in-depth session with code examples see the technical second part of this presentation in the Qt Application Development &amp; Device Creation Track.",
        "endTime": "16:55",
        "isCommunity": false,
        "isDeprecated": false,
        "isKeynote": false,
        "isLightning": false,
        "isMeeting": false,
        "isSession": false,
        "isTraining": false,
        "isUnconference": false,
        "minutes": 25,
        "presenter": [
            "1076"
        ],
        "room": 2,
        "sessionDay": 2,
        "sessionId": 1163,
        "sessionLinks": [
        ],
        "sessionTracks": [
            "16",
            "21",
            "10",
            "17"
        ],
        "sessionType": "",
        "sortKey": "2016-10-2016:30",
        "startTime": "16:30",
        "subtitle": "",
        "title": "How to Develop with Qt for Multiple Screen Resolutions and Multiple Platforms and Best Practices for an Efficient App Lifecycle with Qt (Technology Strategy Session)"
    }
]
